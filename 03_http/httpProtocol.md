# HTTP 통신

## TCP/IP

### 정의 
- 인터넷과 관련된 프로토콜들의 집합
- 4개 계층으로 구성 : 애플리케이션 계층, 네트워크 계층, 링크 계층
- 인터넷이 하나의 프로토콜로 되어있다면 어디선가 사양이 변경되었을 때 전체를 바꾸지 않으면 안되지만, 계층화되어있다면 사양이 변경된 해당 계층만 바꾸면 됨
- HTTP : 애플리케이션 계층 프로토콜임
- 애플리케이션 계층(HTTP 리퀘스트) => 트랜스포트 계층(안내번호, 포트번호) => 네트워크 계층(수신지 MAC 주소) => 링크 계층
- 클라이언트는 계층을 통과할때마다 헤더를 추가함, 서버는 계층을 통과할때마다 헤더를 삭제 (캡슐화)

### 실질적인 HTTP에서의 동작
1. 문자로 된 url 브라우저 창에 입력
2. DNS는 이를 숫자 IP주소로 변환
3. HTTP 담당 웹 서버에 보낼 HTTP 메시지 작성
4. TCP - 통신하기 쉽도록 HTTP 메시지를 패킷으로 분해, 조각내서 일련변호 부여
5. IP - 상대가 어디에 있는지 찾아 중계해 가면서 배송, 개개의 패킷을 상대방에게 전달하는 역할을 맡음 
    - ip 주소 : 각 노드에 부여된 주소
    - MAC 주소 : 각 네트워크 카드에 할당된 고유의 주소
6. 여기까지 클라이언트
7. 그다음 서버 : TCP - 상대방으로부터 패킷을 수신하고 일련번호를 보고 조립
8. HTTP 담당(어플리케이션 레벨) - 웹 서버에 대한 리퀘스트 내용을 처리
9. 리퀘스트 처리하고, 처리 결과도 이 순서대로 클라이언트에 반환함

### URL
- 리소스 식별자 
- 스키마 : 프로토콜 지시
- 서버주소
- 서버 포트
- 계층적 파일 패스(/) : 특정 리소스를 식별하기 위해 서버 상의 파일 패스를 지정
- 쿼리파람(?) : 파일 패스로 지정된 리소스에 임의의 파라미터를 넘겨주기 위해 쿼리 문자열 사용
- 프레그멘트 식별자(#) : 취득 리소스에서 서브 리소스를 가리키기 위해

## HTTP
- 클라이언트 : 텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트
- 서버 : 이러한 리소스를 제공하는 쪽이 서버
- 컴퓨터 2대가 통신을 하는 상황이라면 역할이 거의 명확하게 정해져 있음
- 리퀘스트를 보내야 리스폰스를 보냄

### Request
- 클라이언트에서 보냄
- 메소드, 요구대상 리소스, http 버전 번호, 헤더, 엔티디
#### URI
- 인터넷 상의 리소스를 지정, 리소스를 식별하기 위한 문자열 전반을 나타냄
- URL(Uniform Resource Locator, URI와는 조금 다른 개념) : URL은 리소스의 장소를 나타냄, URL은 URI의 subset
- 리퀘스트에는 URI 형식을 포함해야함(무슨 리소스 요청할지 요청 리소스의 주소 포함)

#### 메소드
이건 머 많이 하긴 했는데
- GET : 리소스 획득, 식별된 리소스를 가져올 수 있도록 요구 
- POST: 엔티티 전송 , 서버에게 정보를 알려줌, 서버는 수신한 데이터의 처리 결과를 돌려준다
- PUT : 파일 전송, FTP에 의한 파일 업로드처럼 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구, 일반적인 웹에서는 보안문제때문에 잘 사용되지 않음
- HEAD : GET과 거의 비슷하게 동작하지만 메시지 바디를 돌려주지 않음, 헤더만 확인함 
- DELETE : PUT과 반대, 리퀘스트 URI로 지정된 리소스의 삭제를 요구


### Response
- 서버에서 보냄
- http 버전, 상태 코드, 상태코드 설명 프레이즈, 리스폰스 헤더, 바디

### stateless
- HTTP는 상태를 유지하지 않는 stateless 프로토콜인데 HTTP 프로토콜 독자적으로 리퀘스트와 리스폰스를 교환하는 동안에 상태를 관리하지 않음
- 쉽게말하면 HTTP 프로토콜 레벨에서 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않음(그걸 기억할 수 있는 구조가 아님)
- 많은 데이터를 매우 빠르고 확실하게 처리하는 범위성을 확보하기 위해 이와같이 간단히 설계되어 있는 것
- 상태를 계속 유지하고 싶은 요구에 부응하기 위해 쿠키라는 기술이 도입되었고, HTTP 통신에서도 상태를 계속 관리할 수 있게 ß되었음

### Persistent Connections
- HTTP 초기 버전에서는 HTTP 통신을 한번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었음 => 비효율적
- 초기에는 통신이 작은 사이즈의 텍스트를 보내는 정도였기 때문에 이렇게 기능을 구현해도 크게 문제가 없었음. 그런데 HTTP가 널리 보급되어감에 따라 오가는 것들이 다양해짐
- 그래서 지속 연결이라는 방법 등장 어느 한쪽이 명시적으로 연결을 종료하지 않는 이상 TCP연결을 유지함
- 오버헤드를 줄여주기 때문에 서버 부하가 경감, 클라이언트가 리소스 띄우는 속도도 빨라짐
- 파이프라인화 : 리퀘스트 하나씩 보내고 기다렸던 과거(지속 연결이 아니기 때문에) 그런데 이제 여러개 한번에 보내고 여러개 한번에 응답 받을 수 있어 빨라짐

### Cookie
- HTTP 통신 상황에서 상태관리
- 예시로 인증이 필요한 웹 페이지에서 상태관리를 하지 않는다면 인증을 마친 상태를 잊어버리기 때문에 새로운 페이지로 이동할 때마다 재차 로그인 정보를 보내든지 그래야함
- 쿠키는 서버에서 리스폰스로 보내진 set-cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됨
- 다음번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때 **자동**으로 쿠키값을 넣어서 송신
- 리스폰스에 Set-Cookie/리퀘스트 헤더에 Cookie


