# HTTPS

## http 약점
- 평문(암호화하지 않은) 통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에(가기만 하면 되서) 위장이 가능
- 완전성을 증명할 수 없기 때문에 변조 가능

### 평문이기 때문에 도청 가능
- 자신을 암호화하는 기능은 없으므로 평문으로 HTTP 메시지를 보낸다
- TCP/IP 구조의 통신 내용은 전부 통신 경로의 도중에 엿볼 수 있다

### 통신상대 확인하지 않음
- 얘가 찐 서버인지 찐 호스트인지 그냥 주소만 있고 통신 상대를 확인하지는 않음
- 누구나 리퀘스트를 보낼 수 있음, 상대가 누구든지 무언가의 리스폰스를 반환
- 위장된 클라이언트였다거나 위장된 서버라면? 접근이 허가된 상태인지 검증하려면? => ssl 증명 사용하기

### 완전성 증명할 수 없으므로 변조 가능
- 정보의 정확성 == 완전성, 증명할 수 없다는 것은 정보가 정확한지 아닌지를 확인할 수 없음을 가리킴
- 그 말은 리퀘스트나 리스폰스가 발신된 후 상대가 수신할 때 까지 사이에 변조되었다고 하더라도 이 사실을 알 수가 없다는 뜻임
- 발신된 리퀘스트나 리스폰스와 수신한 리퀘스트나 리스폰스가 같은지 아닌지를 확인할 수가 없음
- 해시 값을 확인하는 방법이나 디지털 서명을 확인하는 방식으로 해결하지만 한계가 있음

## HTTPS(HTTP Secure)
HTTP에 암호화와 인증, 완전성 보호를 더한 HTTPS

### SSL의 껍질을 덮어쓰다
- 보통 HTTP는 직접 TCP와 통신하지만 SSL을 사용하면 HTTP는 SSL과 통신하고 SSL이 TCP랑 통신함
- 이로써 암호화와 증명서, 안전성 보호를 사용할 수 있게 됨 
- SSL : 널리 사용되는 네트워크 보안 기술

### 공개키 암호화 방식
- 공통키 암호: 암호화와 복호화에 하나의 키를 같이 사용하는 방식 == 공통키 암호
- 키를 줘야 암호화도 하고 암호도 푸는데 중간에 키를 누가 가로채버리면 의미가 없음
- 키를 보내면 도청될 가능성이 있고, 키를 보내지 않으면 복호화할 수 없음. 애초에 키를 안전하게 보낼 수 있다면 틀림없이 데이터도 안전하게 보낼 수 있을 것
- 공개키로 암호화된 http 요청이 오면 서버는 개인키를 이용하여 해독
- 다시 개인키로 암호화하여 요청한 클라이언트에 보내줌
- 개인키로 만든 암호는 공개키로만 풀고 공개키로 만든 암호는 개인키로 푼다(비대칭 키 암호화, 이러면 키를 주고받을 필요는 없어진다)

### 두 개의 키를 사용하는 공개키 암호
- 서로 다른 두 키 페어를 사용, 한쪽은 공개키, 한쪽은 비밀키
- 공개키 암호화를 사용한 암호화는 암호를 보내는 측이 상대의 공개키를 사용해 암호화를 함
- 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용해 복호화를 실시
- 공개키로 암호를 걸고 비밀키로 암호를 푼다(굳이 키를 넘겨줄 필요가 없는건가)
- 암호를 푸는 비밀키를 통신으로 보낼 필요가 없으므로 도청에 의해 키를 빼앗길 걱정이 없음
- 공개키로만 복호화하는건 가능하긴 하지만 매우 어려움(그래서 ㄱㅊ)

### 하이브리드 암호화 방식
- 공개키 암호는 공통키 암호보다 처리가 느려서 모든 통신에 공개키 쓰는건 비효율적
- 공통키 암호로 사용하는 키를 공개키 암호를 사용해서 안전하게 교환
- 클라이언트와 서버가 주고받는 실제 정보는 공통키 방식으로 암호화하고, 공통키 방식으로 암호화된 실제 정보를 복호화할때 사용할 대칭키는 공개키 방식으로 클라이언트와 서버가 주고받는다

### 공개키 증명 
- 인증 기관을 이용하여 진행
- 서버 운영자가 인증 기관에 공개키를 제출하면 인증 기관은 공개키에 서명을 하고 서명이 끝난 공개키를 만듬
- 공개키를 안전하게 클라이언트에 전달하기 위해 브라우저가 주요 인증 기관의 공개키를 사전에 내장한 상태로 존재
- 세션이 진행되기 전에 클라이언트는 서버가 가진 인증서가 믿을만 한지 확인하고, 서버는 서버의 공개키와 인증기관의 디지털 서명을 보내준다
- 그다음에 클라이언트는 공개키를 통해 암호화한 요청을 보내고 서버는 비밀키로 이를 복호화한 후 비밀키로 암호화한 응답을 보낸다 클라이언트는 공개키로 이를 복호화하여 내용을 받아봄

### SSL 인증서
- SSL 인증서는 클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서
- 클라이언트가 서버에 접속하면 서버는 클라이언트에게 이 인증서 정보를 전달
- 클라이언트는 이 인증서가 신뢰할수 있는 것인지 검증한 후 다음 절차 수행
- SSL 인증서의 역할
    1. 클라이언트가 접속한 서버가 신뢰할 수 있는 서버인지를 보장
    2. SSL 통신에 사용할 공개키를 클라이언트에게 제공

### 실질적인 과정

#### 악수
- 실제 데이터를 주고받기 전에 서버와 클라이언트가 수행
- 이때 SSL 인증서를 주고받는다, 인증서에는 서버측 공개키가 포함되어있음
- Client Hello 후 Client Server 이뤄질때 => 암호화 방식에 대한 협상, 인증서 전달
- 그다음에 클라이언트는 인증서의 신뢰성 알아봄 => 이때 클라이언트에 내장된 인증기관 공개키를 이용해 인증서를 복호화 (여기까지는 공개키처럼 키를 같이 넘겨줬음)
- pre master secret이라는 값을 클라이언트는 서버의 랜덤 데이터와 자신의 랜덤 데이터를 조합해서 생성해낸 후 아까 받은 서버 공개키를 통해 암호화해서 서버한테 넘긴다.
- 서버는 이를 복호화하고 pre master secret 값을 공유하게 됨, 서버와 클라이언트는 이 값을 모두 session key로 바꾼다
- 악수단계 종료

#### 세션
- 세션은 실제로 데이터 주고받는 단계
- 실질적으로는 대칭키 방식을 이용하게 된다. 그리고 대칭키(session key)는 이미 공유되었음
- 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key값을 이용해 대칭키로 암호화
- 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키값을 알고 있기 때문에 암호를 복호화할 수 잇음
- 이렇게 악수하고 session key를 만들어내는 과정은 공통키로, 실질적은 데이터 세션은 대칭키로 수행하는 이유 : 공통키 방식이 컴퓨터 파워를 많이 사용하기 때문에 공개키를 그대로 사용하면 많은 접속이 몰리는 서버는 매우 큰 비용을 지불해야 한다. 

#### 세션 종료
- 데이터 전송이 끝나면 SSL이 끝났음을 알려주고, 통신에서 사용한 대칭키인 세션키를 폐기함.

