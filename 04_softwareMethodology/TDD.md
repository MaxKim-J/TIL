# Test Driven Development

테스트 주도 개발

## 정의

- 테스트가 개발을 이끌어 나간다!
- **테스트를 먼저 만들고 테스트를 통과하기 위한 것을 짠다** 
- 만드는 과정에서 우선 테스트를 작성하고 그걸 통과하는 코드를 만들고를 반복하면서 제대로 동작하는지에 대한 피드백을 적극적으로 받는다
- 결정과 피드백 사이의 갭에 대한 인식, 결정과 피드백 사이의 갭을 조절하기 위한 테크닉
- 결정한 대로 빌드가 잘 안되면 => 피드백 => 개발을 하다보면 결정과 피드백 사이에 갭이 생김 => 갭이 커지고 그 갭을 내가 인식할 수 없다면 문제가 생김

## 효과

- 애자일 : 불확실성이 높을 때 피드백과 협력이 중요
- 어떻게 결과가 나올지 뻔하다면야 크게 필요가 없을 수도 있음
- 불확실성이 높을 때 TDD가 빛을 발한다
    - 처음 해보는 프로그램 주제(나에 대한 불확실성)
    - 고객의 요구조건이 바뀔 수 있는 플젝(외부적인 불확실성)
    - 개발하는 중에 코드가 많이 바뀌어야 되는 경우
    - 내가 개발하고 나서 이 코드를 누가 유지보수 할지 모름
- 피드백이 증가 => 테스트를 통과하는 것으로 잘 되고 있는지를 자주 확인 가능
- 협력 : 테스트를 동사에서 명사로
    - 동사는 그 순간에만 하는 것이고 명사는 이후에도 소유가능(record화)
    - test를 저장한다는 것은 남들에게 테스트 코드를 보여줄 수 있고 남들은 그 코드를 직접 실행해볼 수 있음
    - test가 되는 순간 공유하기가 쉬워진다 => 공유하면 협력이 증진되며 용기가 생긴다(내가 남의 코드를 고쳐서 문제가 있더라도 자동화된 테스트가 알려주기 때문에 큰 걱정 없이 고칠 수 있는 용기가 생긴다) => 내가 이 코드를 고쳤는데 망치면 어떡하지, 내가 의도를 모르는데 고쳐도 될까
    - **왜 이렇게 짰을까 궁금할 때 test를 공유하고 그 테스트 코드를 보면 이해할 수 있다.**

## 장단점

- 불확실성에 대한 대비
- 개발 시간이 늘어나긴 하나(테스트 코드를 작성하는 시간) 결함을 줄일 수 있음
- 코드 복잡도가 떨어짐(깨끗한 코드, 낮은 유지보수 비용, 엔트로피 낮아짐)

## 도입이 힘든 이유

- 개발 시간이 증가하기 때문에 단기적인 성과를 중시하는 조직과는 맞지 않는다
- 이때까지 개발하던 방식을 많이 바꿔야하기 때문에 어렵다
- 이렇게 해야된다는 이미지(틀)이 있는데 이런 규칙에 얽매이는건 애자일이라고 할 수 없다

## 좋은 접근법

- 적응적, 친화적으로 접근하기
    - 스스로 어떻게 해야 피드백을 자주 받을까, 어떻게 해야 내가 하는 작업에 대해 협력이 잘 일어나게 할까 - 를 고민
    - 중복적으로 하는 노력들을 자동화하기
- 그렇다고 해서 테스트코드를 관리하지 못할 정도로 막짜면 문제가 생긴다. 테스트를 안 하느니 지저분한 테스트 코드라도 있는 편이 좋다고 판단하면 안된다.

## 단위 테스트(unit test)

- 소스코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차. 모든 함수와 메소드에 대한 테스트케이스를 작성한다. 
- 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목
- 자연스럽게 버그는 테스트를 통해 찾을 수 있고 변경이 쉽게 작성될 수 있으며 코드는 유연해진다. 
- **다른것 보다도 가독성이 매우 중요하다**
- 잡다하고 세세한 코드를 없애고 좋은 이름을 붙인 함수와 진짜 필요한 자료형만 사용한다.
```java
// 개선 전 테스트코드
@Test
public void turnOnLoTempAlarmAtThreashold() throws Exception {
  hw.setTemp(WAY_TOO_COLD);
  controller.tic();
  assertTrue(hw.heaterState());
  assertTrue(hw.blowerState());
  assertFalse(hw.coolerState());
  assertFalse(hw.hiTempAlarm());
  assertTrue(hw.loTempAlarm());
}

// 개선 후 테스트코드
@Test
public void turnOnLoTempAlarmAtThreshold() throws Exception {
  wayTooCold();
  assertEquals("HBchL", hw.getState());
}

```

## 규칙

- 테스트 함수마다 한 개념만 테스트하는게 좋다. 이것저것 잡다한 개념을 연속으로 테스트하는 긴 함수는 피한다.
- 테스트는 빨리 돌아가야 한다. 느리면 자주 돌릴 엄두를 못내기 때문이다. 자주 돌리지 않으면 초반에 문제를 찾아내 고치기도 힘들다. 코드를 정리하지도 못한다.
- 각 테스트는 서로 의존하면 안된다. 한 테스트가 다음 테스트 실행 환경을 준비해서는 안된다. 서로 독립적인게 보장되어야 하고 어떤 순서로 실행해도 괜찮아야 한다. 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패한다.
- 테스트의 결과는 단순해야한다. 성공 아니면 실패! 통과여부를 알리고 로그파일을 읽게 만들어서는 안된다. 
- 테스트는 적시에 작성해야 한다. 단위 테스트는 실제 코드를 구현하기 직전에 구현.

## 코드 커버리지

- 말 그대로 테스트를 통해 코드가 얼마나 커버되었느냐
- 구문, 조건, 결정을 얼마나 잘 커버하였는지가 기준 => 수치화 가능