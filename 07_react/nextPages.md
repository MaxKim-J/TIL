# next.js의 동작방식

2020.03.10  
[next.js doc의 pages](https://nextjs.org/docs/basic-features/pages)번역글

## 페이지

1. 넥스트에서 페이지는 pages디렉토리에 들어있는 리액트 컴포넌트임.
2. 각각의 페이지는 파일 이름과 동일한 라우트 주소를 가짐
3. 다이나믹 라우트 페이지를 만들고 싶으면 `pages/posts/[id].js`일케댐(이거 경로가 아닌가?)

## 프리 렌더링

1. 일단 기본적으로 넥스트는 모든 페이지를 프리렌더링한다
2. 이말인 즉슨 자바스크립트로 html을 다 새로 그려버리는 클라이언트 사이드 렌더링 spa와 달리 넥스트는 미리 모든 페이지에 대한 html을 미리 만들어낸다.
3. 프리 렌더링 하는게 당연히 seo에 도움이 된다 => 알고있지만 한 번 써보자면, 구글이나 포털들의 검색엔진 크롤링 봇들은 클라이언트 사이드 렌더링으로 그려질 "예정"인 spa들의 html 내용을 긁어오지 못한다. 빈 html일 뿐. 서버사이드 렌더링을 하면, 봇들이 긁어갈 때 완성된 html을 긁어올 수 있으므로 seo가 잘 수행될 수 있도록 한다.
4. 만들어진 html들은 소량의 자바스크립트 코드와 연관이 되어있고, 페이지가 브라우저에서 로드될 때 자바스크립트 코드가 실행되어 페이지를 완성시킨다 -> 이 과정을 **하이드레이션**이라고 부른다.

## 하이드레이션

1. ssr은 spa의 성능을 개선하기도 하는데, spa같은 경우 페이지 **렌더링에 필요한 모든 자바스크립트들을 먼저 다운로드해야 한다.** 그래서 시간지연이 발생하는데 이 문제를 완화하기 위해 리액트와 뷰 모두 탐색 요청 시 서버에서 돔을 **사전에 렌더링**하도록 지원함 (이게 넥스트랑 넉스트 뜻하는 말인가????). 그러면 클라이언트 측 자바스크립트가 렌더링을 픽업해서 나머지 작업을 수행하게 되는데, 이 프로세스가 바로 하이드레이션.
2. 넥스트의 렌더링 과정
   - 서버에서 string 형태의 html을 렌더링
   - 이 html을 소스코드로 유저에게 보냄
   - 자바스크립트 코드 유저에게 보냄
   - 리액트 코드를 통해 html을 하이드레이팅함
3. 하이드레이트가 이 과정에서는 무엇을 뜻하냐면, 넥스트는 **리액트 코드를 html 위에서 먼저 적용**시키고, 리액트로 하여금 이 프로세스를 처음부터 다시 거치지 말라고 지시를 내린다. 리액트는 넥스트가 렌더링 해놓은 html에 이벤트 핸들러를 붙여서 spa처럼 렌더링되는 것처럼 보이게 만든다. 즉, **넥스트는 리액트가 기존에 했었던 역할을 분담한다**
4. 이렇게 되면 유저는 싹 다 렌더링된 페이지를 볼 수 있고, 볼 수 있게 된 다음에 인터랙티브 해진다. 브라우저는 리패인팅이 필요 없으니 성능상에 이점을 얻는다.
5. cra spa => 자바스크립트 코드 로딩 => 빈 html에 돔 그리기 => 유저 짠!/인터렉티브 짠!
6. ssr next => html에 내용 채우고 리액트 컴파일해서 자스 조금 적용 => 유저에게 렌더링된 html전달 => 유저짠! => 리액트가 이벤트 등 짜잘한 자스 처리/인터렉티브 짠!

매우 간단하게 말하면 **넥스트 그 자체(서버사이드 + 클라이언트 사이드)**
[괜찮은 설명 1 - 댓글](https://spectrum.chat/evergreen/help-me/ssr-and-hydration-for-next-js~52a4ffd5-7fd5-4b6b-b068-262e005fdf00)  
[괜찮은 설명 2 - 대충 이거 번역함](https://medium.com/@luke_schmuke/how-we-achieved-the-best-web-performance-with-partial-hydration-20fab9c808d5)

## 프리렌더링 두가지 종류

넥스트는 두가지 프리랜더링 타입을 가지는데,

```shell
### 정적 생성(추천되는 방식)
npm run build할 때 html이 다 생성이 되고, 각각의 리퀘스트에 재사용된다

### 서버사이드렌더링
html이 각각의 요청이 올 때에 맞춰 생산된다.
```

1. 넥스트는 당신이 무슨 방법을 택할지 정하게 냅둔다.
2. 두개를 쓰까쓸 수도 있다.
3. 정적 생성 방식을 추천하는데, 성능 문제 때문이다. 정적 생성은 cdn에 의해 캐시되기 때문에 성능을 향상시킨다. 근데 가끔은 서버사이드렌더링만 가능한 상황도 있을 것이다
4. 그렇다고 해서 클라이언트 사이드 렌더링을 쓸 수 없는 건 아닌데, 페이지의 어떤 부분은 클라이언트사이드 렌더링을 적용할 수도 있따. gip 사용법을 보면 이해할 수 있을 것이다,,

## 정적 생성 방식

1. build time에 페이지가 빌드된다.
2. 배포용일때는 페이지 html이 next.build할때(!!!!!)다 만들어져 있다는 것이다;;;
3. 이 완성된 html들은 각각의 요청에 대해 재사용된다. cdn에 의해 캐시되는게 가능하다.

### 데이타 없이 정적생성

```javascript
function About() {
  return <div>About</div>;
}

export default About;
```

패치나 이런거 할 필요도 없고, 외부 데이터를 미리 렌더링시켜서 갖다쓰지도 않으니, 넥스트는 이런 상황에서 간단히 그저 하나의 html파일을 npm run build할때 만든다.

### 데이터와 함께 정적생성

1. 페이지의 내용이 어떤 외부의 데이터와 관련이 있따면 getStaticProps를 사용한다
2. 페이지의 경로가 외부의 데이터와 관련이 있다면 getStaticPaths를 사용한다.
3. 음 근데 사실 build 할 때만 생성되는 그런거네 데이터가 시시각각 바뀐다면 사용할 수 없을듯?
4. 정적 페이지를 빌드하는 방법이 이런 것일듯 싶음. 블로그 만들 때 활용 가능할듯?

```javascript
// 걍 패치
import fetch from "node-fetch";

function Blog({ posts }) {
  // Render posts...
}

// 이 함수는 run build할 때(만) 호출된다!!!!!!
// 어싱크랑 어웨잇도 부를 수 있다.
// 그 외는 gip랑 똑같은듯
export async function getStaticProps() {
  const res = await fetch("https://.../posts");
  const posts = await res.json();

  return {
    props: {
      posts
    }
  };
}

export default Blog;
```

### 경로와 함께 정적생성

1. 뭐 위에랑 비슷한데, 패치를 한 블로그 글의 아이디같은걸 먼저 파싱해서 이 정적 html의 유알엘로 쓰게 해주는 뭐 그런거가틈
2. getStaticPaths()와 getStaticProps()는 동시에 쓰는게 가능함

```javascript
export async function getStaticPaths() {
  // ...
}

export async function getStaticProps({ params }) {
  // 파람으로 이어받는다
  const res = await fetch(`https://.../posts/${params.id}`);
  const post = await res.json();
  return { props: { post } };
}
```

### 정적 생성은 언제 써야댐?

1. 당신의 페이지가 **딱 한번만 빌드되면 땡인** 상황이거나, cdn을 통해 제공받을 수 있을 때
2. 모든 리퀘스트에 대해 페이지를 서버렌더링하는 상황보다 무척 낫다
3. 마케팅 페이지, 블로그 포스트, 이 커머스 프로덕트 리스팅(안변하는), 헬프페이지, 도큐멘테이션 등 주로 **정적 페이지**에 활용할 수 있는 렌더링 방식이다.
4. 내가 이 페이지를 유저의 요청에 상관 없이 빠르게 일단 만들어놓을 수 있을 것 같은데? 하는 생각이 들면 정적생성을 해도 된다.
5. 유저 리퀘스트에 따라 depend되는 경우 정적 생성이 좋은 생각은 아니다. 리퀘스트에 따라 계속 페이지가 변해야한다면 정적 생성은 좋지 못한 방법이다.
6. 이런 상황일 때는
   - 정적 생성과 클라이언트 렌더링을 같이 쓴다 : 프리 렌더링 과정을 뛰어넘고 그냥 자스로 그린다.
   - 그냥 서버사이드 렌더링을 쓴다 : 유저의 요청에 맞춰 서버가 미리 렌더링을 해놓는다.

### 서버사이드 렌더링

1. getServersideProps를 사용한다. => 옛 버전의 getInitialProps와 대응(!)
2. gip에 대해서 알고있어야 할 것들
   - gip는 데이터를 동시적으로 패칭할때 사용하고, prop으로 통합
   - gip는 객체를 반환해야 한다
   - 페이지가 처음으로 로딩될 때, gip는 서버에서만 로딩됨
   - 라우터나 링크를 이요하여 이곳저곳 다닐때 gip는 클라이언트 사이드에서 로딩됨
   - 페이지 컴포넌트에서만 쓸 수 있음
   - [서버에서만 쓰는 모듈들을 임포트할때 주의](https://arunoda.me/blog/ssr-and-server-only-modules)
