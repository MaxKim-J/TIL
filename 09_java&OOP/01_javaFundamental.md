# 01_자바 기본

다 까먹었을테니 정리해보자구  

## 개발 배경

- 90년대 그당시엔 임베디드를 자바로 돌리려고 했음 : C 컴파일을 운영체제별로 하는 작업을 대체하려고. 각 기기마다 운영체제가 다른데, 어떤 플랫폼에서든 작동하는 언어를 만드려고 해서
- 근데 갑자기 인터넷이 빵터지면서 온갖 사용자 컴퓨터와 운영체제들이 사용되기 시작했는데 그쪽으로 방향을 바꾸며 대중화가 되었고 인기도 많아졌음
- 가장 많이 쓰이는 매니지드 언어 : 매니지드 언어라서 메모리 관리를 덜 신경써도 됨. 기계와 아주 가깝지 않은 개념을 코드로 옮기기에 적합(물론 자바보다 기계랑 더 떨어진 언어들도 있는듯 파이썬이라던가..)
- 한국 개발씬을 먹은 언어...

## 문법 빠르게 훑기

### 1. 헬로월드

프로그램 하나 실행시키는데 필요한 것들이 무엇인지 살펴보기  

```java
// helloWorld.java
package hello.world

public class Hello {
  public static void main(String[] args) {
    System.out.println('hello world')
  }
}
```

- verbose...
- <접근제어자> class <클래스명>
- 자바에서는 언제나 클래스가 필요하다. 실행문들은 무조건 클래스 안에 들어가야된다. 헬로월드 하나 찍더라도...
- .java 파일에는 최고 레벨 public 클래스가 하나만 있어야 하고 둘 이상일 경우에는 컴파일이 안됨
- 클래스 안에 다른 클래스를 넣을 수 있고 내포 클래스라고 부름. 내포 클래스는 public이어도 상관 없음
- main 함수 : 약간 JVM과 `코딩을 이렇게 하겠다`는 약속 정도로 생각하면 좋을듯. 프로그램의 진입점이자 시작점. 시그니처를 저렇게 유지해야함 클래스의 메인 메서드가 없으면 실행중 오류
  - `public static void main(String[] args)`의 매개변수 String[] args : 문자열 배열인데 커맨드 라인으로부터 받은 인자. 실행문을 문자열로 받나본데? 더 알아볼것

### 2. 출력문

```java
System.out.println('hello')
System.out.println(123454)
System.out.println(3.14)
System.out.println('hello' + 100)
```

- System.out.println() : 표준 출력으로 한 줄을 출력하는 함수. 문자열뿐만 아니라 숫자도 출력이 가능하다.
- System : 자바에서 자체적으로 제공하는 클래스
- out : System 클래스의 정적 멤버 변수, 객체임. out의 자료형은 PrintStream 클래스인데 이건 자바의 표준 출력 스트림이다.
- println : 정적 멤버 변수인 out의 메서드 중 하나
- 타입에 상관없이 출력이 가능한데 이건 오버로딩(인자만 다르게 하고 반환형은 같은 함수인데 인자에 따라 지정해서 호출)때문에 가능하다

```java
public void println(int x);
public void println(float x);
public void println(char x);
public void println(String x);
```

- printf : 문자열 포매팅. C의 printf처럼 포맷팅이 가능하다. 

```java
// \n의 경우 linux에서 \n, windows에서 \r\n을 반환해야 가능하다
// System.lineSeparator()을 사용하면 os별로 맞는 줄바꿈을 실현한다
// public static String lineSeparator();

System.out.printf("%s`s score: %d%s", name, score, System.lineSeparator());
```

### 3. 가변인자

매개변수의 수가 달라질 수 있는 경우  

```java
// 아무거나 받음
public PrintStream printf(String format, Object... args)

// int만 받음
public void printScores(int... score) {}
```

- 앞에 자료형을 넣어야 하고 해당 자료형의 데이터만 인자로 전달 가능
- Object 자료형을 쓸 경우 모든 자료형을 넣을 수 있음. 모든 자료형의 부모 오브젝트...

### 4. 패키지

```java
package hello.world   // 패키지 경로

public class HelloWorld {
  public static void main(String[] args) {
    System.out.println('hello world');
  }
}
```

- 연관된 클래스들끼리 묶는 기법. 일종의 라이브러리이자 네임스페이스
- 마치 디스크상의 폴더와 같은 역할
- 자바 빌트인 패키지 : 자바(java.)로 시작하는 패키지들
- 프로그래머가 직접 만든 유저 정의 패키지
- 패키지의 목적 : 네임스페이스 충돌 방지
- 패키지 이름의 중복을 최소화해야 함 보통 회사의 도메인명을 패키지 이름에 사용한다고...
- 패키지를 정의했으면 이하의 클래스가 이 패키지에 속한다는 것을 말한다. 
- 근데 패키지만 저렇게 이름만 적으면 안되고 폴더 구조도 변경을 해줘야되는데, 패키지명과 똑같은 폴더 트리에(.으로 구분되는거 상하관계까지 해서) .java 파일을 넣어야 한다. 써주기도 하고 폴더도 그렇게 만들어줘야 함. 같은 그룹에 있게끔
- IDE는 알아서 해줌 개꿀
- 파일 디렉토리마저 객체지향적이네 자바 당신은 도덕책

### 5. 자바 프로젝트 폴더 구조

> 프로젝트 최상위 폴더 -> src -> hello -> world -> 하위 패키지 or HelloWorld.java

- src : 모든 .java 파일이 들어가는 폴더. 거기서부터 패키지를 찾기 시작함
- 패키지 디렉토리에는 자바 파일 클래스와 똑같은 이름의 java파일이 들어가면 된다
- 하위 패키지도 만들 수 있음 계속 .을 이어나가는 느낌으로
- C#의 네임스페이스와 비슷한 기능인데 폴더 구조는 일치할 필요가 없다 씨샵같은 경우는...

### 6. 컴파일

- 커맨드라인 컴파일 : 컴파일한 자바 클래스의 패키지 이름과 동일한 폴더들이 class(컴파일 결과물을 저장할 경로) 폴더 아래에 생기고, .class 파일이 최종 생성

```shell
# javac -d <컴파일 결과물을 저장할 경로> <컴파일할 .java 파일>
javac -d class\ src\hello\world\*.java
```
- src와 동등한 위치에서 class라는게 하나더 생기는 식으로 컴파일
- javac : 자바 컴파일러 명령어, java 파일이 무사히 컴파일이 되면 .class 파일이 나옴. 이름은 .java와 동일하고 **바이트 코드**가 들어있음
- -d : 디렉토리, .class 파일을 저장할 경로 설정
- 바이트코드 : 기계어랑은 조금 다름
- 컴파일되었으면 실행, 어떤 폴더 안에서도 실행 가능(경로를 인자로 넣어주기 때문)

```shell
// 클래스 폴더의 루트를 넣어줌
java -classpath D:\hello\world\class\ hello.word.HelloWorld
```

- 자바는 컴파일한다고 OS가 알고있는 실행 파일을 주는게 아니고, 바이트 코드로 컴파일이 되는데 java 명령어는 그 바이트 코드를 실행하는 명령어임
- 역시 main함수가 들어가 있어야 함
- 배포할때는 .jar파일을 만들어주는데 클래스파일을 다 뭉쳐주는거 src, class 다 만들어주고 그 디렉토리에 lib 만들어서 배포. 아래 명령어 실행하면 lib에 jar 만들어짐

```shell
# jar <option> <jar 파일 이름> <최상위 패키지 경로>
jar -cf ..\lib\helloWorld.jar hello
```
- .jar 실행 => .jar은 단순히 압축파일이고, 압축 프로그램으로 풀 수도 있음
- jar 내부에 MANIFEST.MF 라는 파일이 같이 생성하는데, 이게 자바 애플리케이션의 정보를 담고 있는 메타데이터 파일로, .jar파일의 시작점에 대한 정보를 넣어야 함. 어디에 가야 내 메인 함수가 있다던지...
- src 폴더에 Manifest.txt를 만들어서 넣어준다. jar 만들때 -cfm 써서 만들어주면 되고, 그러면 jar을 실행할 수 있음

```txt
MAIN-CLASS:패키지 경로
```

### 7. 패키지 사용하기

- 외부 패키지는 import 키워드로 사용
- package는 파일의 클래스가, import는 외부의 클래스를 사용할때
- 다른 패키지 안에 있는 클래스에 접근하기 위해 사용

```java
// 명시적으로 드러내주는게 중요
import java.util.Random;
// 모든 클래스
import java.util.*;
```

- java.lang : 기본 패키지로 import 없이 사용 가능. 사실상 `import java.lang.*;`이 모든 파일에 자동으로 들어감 System 같은거

### 8. 자바의 실행 모델

- 자바는 한번만 빌드하면 어디서든 돈다 : 장점으로 항상 언급되는 부분 
- 반만 맞는 말임 근데 : 컴파일 실행 과정을 알아봐야함
- 전통적인 컴파일 방식 : 소스코드 => 어셈블러 => 어셈블리 => 오브젝트 코드 => 링커로 외부 참조문제 해결 => 기계어(.exe)
- exe: 실행 파일은 기계어이며 운영체제가 직접 실행하는 파일. 각 운영체제와 디바이스마다 실행 파일을 따로 만들어야 함 이때 컴파일러가 소스코드를 각 운영체제/디바이스에 맞는 기계어로 바꿔주고 소스코드는 안 바꿔도 됨. C는 이런 관점에서 돌리지 못하는 곳이 없는 크로스 플랫폼임
- 근데 자바는 기계어 이런게 없고 바이트코드는 실행파일이 아님
- 바이트코드란 JVM이라는 프로그램이 이해하는 명령어로, 얘가 실행을 할때 바이트코드를 실행하는 머신에 맞게 JVM은 최종 플렛폼에 맞는 명령어로 바꿔서 실행해줌. 기계어보다는 느림.
- 자바 가상 머신(JVM) : 운영체제에 설치하는 별도의 프로그램이고 Java의 바이트 코드를 실행함. 각 운영체제 디바이스마다 다른 버전을 설치. 이런 개념 면에서는 실행 파일을 따로 만들 필요가 없다는 점에서 크로스 플랫폼이 되는거임
- 근데 그러면 자바의 플랫폼은 JVM임 운영체제가 아님. 안깔면 안돌아가니까 이런 관점에서는 크로스 플랫폼이라고 하기에는 엄밀하게 맞는건 아님

### 9. 자바가 인기가 있었던 이유

- 자바 애플릿 : 더이상 안쓰는데.. 웹 브라우저 안에서 실행가능한 작은 자바 프로그램. 닷컴버블 시절에는 브라우저에서 웹문서 보는거밖에 못했는데, 인터넷에서 도는 프로그램을 만들어줬던게 자바 애플릿. 바이트코드를 웹에 업로드를 해놓고 웹브라우저에 상관없이 애플릿을 지원한다면 패키지 다운받아서 실행 가능. 웹 브라우저 안에 JVM이 들어가 있었던 상황
- 데스크탑 수준의 기능을 웹에서 실행 가능했던 거의 유일한 플랫폼. 새로운 플랫폼이 나오더라도 다시 컴파일하지 않아도 되었음 바이트코드 그대로 실행 가능
- 지금은 사라짐. 브라우저들은 지원 안함. 자바스크립트와 웹어셈블리가 대체. 서버에서 실행되는 비슷한 개념의 프로그램 서블릿은 아직 좀 돌아감.

### 10. 구조적 프로그래밍 요소

- 기계가 명령어를 실행하는 방식이라 왠만한 패러다임이나 언어들이 따르는 방식
- 자바는 합리적으로 잘 나눠진 자료형을 가지고 있음(byte, short, int, long, float, double, boolean, char) => 자료형 크기가 고정

#### unsigned가 없음

- unsigned가 없음 : 모든 자료형이 signed임(음수양수 다 들어갈수 있는). char은 무조건 unsigned
- 왜? : 잘 알지도 못하는거 그냥 사용하기 쉽게 만들자 그러나...
- 단점 : 배열의 길이를 저장할때 length에 0보다 작은 값이 들어갈 수 있음. int age 만들었는데 여기다가 음수가 들어갈 수 있음(????) => 컴파일도중에 이런걸 잡아주지 못함
- **코드를 방어적으로 작성해야한다** : 조건문이 필요하다 어디까지 틀린값인지를 개발자가 정의해줘야되고...
- Integer클래스 : parseUnsignedInt라는 메서드로 언사인드 인트 지원하려고 막 함 헬퍼함수 개념. 근데 스트링으로 한번 바꿔야댐 => 불편함

#### char

- 유일한 unsigned 2바이트 자료형인데... 왠만한 유니코드를 표현할 수 있으나 모든 유니코드를 표현할 수 없음 => 나중에 이모티콘 같은거 표현하려면 더 큰 자료형이 필요
- 기본 자료형 : 모두 reference by value : 대입을 할 경우에 값 복사

#### String

- 얘는 클래스라서 참조형이다. 연속된 문자를 저장하는 메모리와 데이터 처리할 수 있는 각종 메서드 있음
- new로도 생성 가능
- 불변형 : 바꾸고 싶다면 새로운 문자열을 만들어야 함. [0]같은걸로 문자열의 일부를 변경할 수 없음(이거 파이썬이랑 똑같구나)

### 11. 리터럴

- int : 없음
- long : L 끝에 붙임. 안넣으면 오류
- 16진수 리터럴: 0x
- 2진수 리터럴 : 0b
- 8진수 리터럴 : 0
- float : f
- Double : D, 보통 생략
- 문자 : '' 
- 스트링 : ""
- null : 참조형에 사용 가능한 리터럴이자 참조하는 대상이 없음을 나타냄
- _ : 큰 숫자의 가독성을 높이기 위해 사용

### 12. final

- const 대신에 final 키워드를 사용

```java
// 변수값 변경 금지
final int MAX_STUDENT = 10;
MAX_STUDENT = 30;
```

- 지역 변수, 클래스 멤버 변수, 메서드 매개변수, 클래스와 메서드에 사용가능
- public static final int 이런식으로 사용 가능
- 매개변수의 값 변경 막을 수 있음
- 선언 후에 대입을 딱 한번까지만 할 수 있는 느낌. 선언과 대입을 다른 실행문에서 해줄수도 있음

```java
public void printScores() {
  final int MAX_CLASS;
  MAX_CLASS = 5;
  System.out.prinf("%d", MAX_CLASS);
}
```

- 멤버변수인 경우는 좀 애매한데, 생성자에서 초기화 가능함

```java
// 예시
public class StudentManager {
  final int MAX_STUDENT;
  public void printScores() {
    final int MAX_CLASS:
    MAX_CLASS = 5;
    System.out.printf("%d, MAX_CLASS");
  }

  public StudentManager() {
    MAX_STUDENT = 10;
  }
}
```

### javadoc

자바의 특별한 주석

```java
/**
 * 이게 
 * 바로
 * 자바독이라네
 * @param 이렇게 하면 태그를 함
 * @return 요건 반환값 태그
 * /
```

- 클래스, 메서드, 멤버 변수, 인터페이스 위에 위치하고 자동으로 Java API 문서를 생성하기도 함

### 연산자

- 기본적으로 숫자를 표현하는 자료형만 피연산자로 사용 가능. 문자열(String) 더하기만 제외하고. 불리언형은 사용 불가
- String도 클래스라서 참조형임. 대입 연산자는 값을 바꿀 수 없음. 그대신 가리키는 대상이 바뀜(참조가 복사됨 => 그렇다면... 값을 바꾸면 같이 바뀌는구나....오...)

### 캐스팅

```java
// 암시적 캐스팅(프로모션) => 잘들어감
int i = 10;
long l = i;
float f = l;
double d = f;

// 명시적 캐스팅 => 데이터의 손실
double d = 12324.985656;
float f = (float) d;
long l = (long) f;
int i = (int)l;
```

- 클래스 역시 규칙에 따라 캐스팅이 가능한 경우가 있음

### 논리연산자

- short circuit 평가를 함(이게 뭐지)

### 문자열 비교

자바의 문자열은 참조형이라는 충격적인 사실  

- ""와 new String()의 차이
- 문자열 변수에 저장되어 있는 것은 값이 아니라 메모리 주소
- == 가 비교하는 대상은 주소를 비교하고, 실제 문자열을 비교하는게 아님
- 문자열끼리 주소를 공유하는 경우가 있음 => String을 new로 생성하지 않은 경우. 같은 문자열을 String에 대입하면 같은 주소를 공유하도록 내부 최적화를 해놓은것(????졸라 이상하네)

```java
// 둘은 같은 주소를 가리킴
String name1 = "nana";
String name2 = "nana";
```

- 값만을 비교할 경우 : 메서드를 써야함; `equals()` 메소드
- C나 C++은 **연산자 오버로딩**이 가능해서 연산자에 대한 세부적인 정의가 가능하다. 파이썬의 특별 메소드처럼 => 자바에서는 지원을 안한다!!!! 다만 문자열 더하기 정도만 지원할뿐
- 근데 생각해보니까 JS에서도 지원을 안한다
- 자바는 메서드 오버로딩정도는 지원함
- 문자열 더하기 할때는 캐스팅을 자동으로 해준다

### 조건문 반복문

- goto문은 없는데 특정 루프를 라벨링해서 break하거나 continue하는 기능이 있다
- 향상된 반복문(forEach 스타일의 반복문)

```java
int[] scores = {10, 20, 30, 40};
// elem자료형 : 배열 변수명
for (int score: scores) {
  System.out.printf("%d ", score);
}
```

### 참조형 인자

- 참조형을 인자로 넘길때는 조심해야. C에서 포인터를 넘기는 것과 마찬가지
- **모든 것이 포인터** 이말을 여기서 들을지는 몰랐네..
- 메서드 안에서 참조형 인자의 값을 바꾸면 원본이 바뀐다 => 이건 사실 여느 하이레벨 언어랑 비슷한거같다
- 메서드 인자에 final을 붙이면 원본을 못바꾸나요? => 여전히 바뀜. 참조형 변수는 주소를 저장하고, 따라서 final이 붙으면 그 주소만 변경 못함 but 그 주소가 가리키는 값을 여전히 바꿀 수 있음(참조형 안에 든 멤버변수라던가 - 이것도 자바스크립트랑 비슷함)

### 배열

좀더 자세히 추가정리할것

```java
// 이러면 만들어지기는 하는데 값은 순회해서 넣던지 해야함
int[] nums = new int[5];
int scores[] = new int[20];
```

- 다차원 배열은 배열 안에 배열에 더 가까움

### 열거형(enum)

```java
public enum Direction {
  North,
  South,
  West,
  East
}
```

- 얘는 클래스임. 독자적으로 선언하거나 클래스 내부에 선언 가능
- 대입은 못함 정수형이 아니라서(이건 타입스크립트랑 좀 다른듯)
- 그냥 데이터로만 사용해야함 => 멤버 변수나 함수도 넣을수 있음(???)
- 마지막 상수 끝에 `;`
- new는 못씀(?????)

```java
// 굳이 값을 넣고 싶다면 이런 방법이 가능하긴 하다
// 생성자에서 처리
enum Subject {
  KOREAN(2),
  ENGLISH(3),
  MATH(6)

  private int hours;

  public int getHours() {
    return hours;
  }
  // 생성자
  Subject(int h) {
    hours = h;
  }
}
```

### var

- 동적 타입은 아닌데 컴파일러가 알아서 자료형을 추론해줌
- 근데 가독성을 해칠 수 있다
- 그냥 안써야할듯ㅋㅋㅋ

### 람다

- 이름 없는 익명 함수, 내포 함수
- () -> {}

### 모듈

- 자바도 모듈 시스템이 최근부터 도입이 되어따
- 기본 방식 패키지 시스템의 한계
  - 애플리케이션이 사용하는 클래스 목록을 찾는 공식적인 방법이 없음
  - 사용중인 패키지에 있는 모든 클래스를 같이 배포해버림;;
  - public 클래스를 아무나 사용할 수 있음. 때로는 public 중에서도 일부만 외부에 노출하고 싶은데 그럴 수 없음
- 패키지를 내포하며 패키지보다 상위 개념
- module-info.java가 모듈에 필요한 데이터를 가지고있음 의존관계라던가
- 번들링을 더 효율적으로 하게 됨

```java
module pocu.academy.core {
  // 요고만 공개
  exports pocu.academy.core.math;
  // 모듈에서 사용하는 외부 모듈
  requires java.sql;
}
```

## 더 정리

- short circuit
- (hash)map
- 배열 좀더