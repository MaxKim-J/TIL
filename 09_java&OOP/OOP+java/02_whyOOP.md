# 02_객체지향 프로그래밍의 필요성

## 절차적 언어의 아쉬운 점 

- 표현하고 싶은 데이터가 그 하나하나가 의미가 있다기 보다는 개념들이 모였을때 의미가 있는 경우가 더 많음(학생 => 성적 이름 반 번호로 이루어짐)
- 절차적 프로그래밍에서는 이런 데이터들을 학생, 성적, 이름이라는 배열에 저장하는 셈인데. 데이터가 많아지면 분산되서 관리하는 경우 관리가 힘들다. 실수할 여지도 증가함
- 이런 상황을 보완하기 위해 절차적 언어에서 지원했던 것이 **구조체** : 데이터를 그룹으로 묶어 새로운 데이터형을 만드는 방법

```C
// 새로운 자료형

// 구조체 선언, 스펙을 정의 : 이 타입형이 어떤 특징을 가지는지
struct Human 
{
  int age;
  float height;
}

// 구조체 변수의 선언 : 전자의 정의에 따라 새로운 Human을 만듬
Human max
max.age = 10;
max.height = 170.0f;
```

- 그런데 구조체도 한계가 있다 : 여전히 데이터와 동작이 분리되어 있기 때문 
- 함수를 선언해서 사용할때, 구조체로 선언한 변수를 인자로 사용할텐데 이 두개가 따로 떨어져있어 어떤 구조체가 어떤 함수랑 연관있는지 찾기 복잡하다
- 올 근데 주제랑은 상관 없는데 클린아키텍처에서 진정한 변수의 은닉화는 C에서의 구조체(데이터와 함수가 분리되어있는 형태)라고 말했던게 생각난다.
- 구조체에 함수까지 하나로 묶을 수 없을까?????? 뭔가 만들어서 변수와 함수를 다 담고싶다

```C
// 내가 알아서 찾아야댐
void eat(Cat*, cat){}

struct Cat
{
  int age;
  string name;
}
```

- C에서의 방식은 파일을 분리하는 것. 즉, 헤더파일에서 구조체 변수와 이를 변형하는 함수를 다 선언한 다음에 실행파일과 분리하고 실행파일에서 헤더파일을 include해서 사용하는 방법 => 뭐 근데 프로그래밍 언어 자체에서 지원하는 것은 아니다.

```c
// dog.h
struct Dog
{
  int age;
  string name;
};

void bark(Dog*, dog);

// dog.c
#inclue "dog.h"
void bark(Dog*, dog) {

}
```

## 보다 근본적인 문제 - 실세계에서 사람은 어떻게 생각하고 행동할까?

- 실세계에서는 기능을 수행할때, 어떤 동작을 부탁해야하는 대상이 존재한다. **그 기능을 실현하는 주체가 필요**
- 그리고 그 주체에게 그 기능을 실행하는데 필요한 정보를 공유
- 사람은 세상을 물체의 집합으로 인지한다 => 물체는 상태를 가질 뿐 아니라 동작도 할 수 있음
- 변수: 상태 저장 + 함수: 동작 = 개체 : 상태 외에 동작까지 포함
- 변수와 동작을 그 개체의 특성에 맞게 그룹화시켜야 올바르게 동작함
- 다만 모든것이 개체는 아니다 : 같은 엑셀 파일의 같은 줄을 계속 업데이트하는 상황. 얘는 순수한 데이터에 가까움. 상태가 변할 수 있음(세상 모든 것들이 상태와 동작의 결합이라고 생각하지는 않고 어떨때는 상태만, 기능만 있다고 생각할 수도 있다)
- 뭐 객체지향으로 만들 수 있는게 많긴 하지만 모든 것을 커버할 필요가 없다.

## OOP

- 프로그래밍 패러다임 중 하나, 프로그램을 구성하는 기본 요소를 개체로 보려는 노력
- OOP에서의 프로그램 : 상호작용하는 개체들의 집합. 절차적 프로그래밍은 실행할 명령어의 목록을 프로그램으로 봤음
- 절차적 : 어떤 블랙박스가 있고 인풋과 아웃풋. 속에 들어갔다 새로운걸로 나온다
- 객체지향 : 객체들의 상호작용으로 인해 어떤 객체의 동작으로 인해 상태가 바뀌는
- 기계어는 위에서 아래로 차례대로 시행됨. 어셈블리 명령어는 거의 모든 경우 1:1치환 가능 그 명령어 실행 결과에 따라 레지스터 또는 메모리에 저장된 데이터가 변경
- 이러니까 사실 절차적 프로그램은 매우 직관적이고 객관적 : 작동하는 기계, 프로그래머의 주관이 개입할 여지가 적음
- OOP는 기계처럼이 아니라 사람처럼 생각하자는 운동. **사람처럼 프로그래밍하자** 근데 사람은 같은걸 보더라도 해석이 다른 존재
- 그리고 사회와 기술이 발전함에 따라 사람들이 사고방식도 변함 그래서 OOP는 주관적 => 뭐 여러가지 학설과 관점이 있었지만 자바랑 C++이 교통정리를 끝냄, 다수가 따르는 OOP 개념이 있음

## 피해야할 주장

- 순수 객체 지향 : `순수`의 의미가 뭐냐? 마치 탈모약을 먹으면 정력이 준다고 하는데 사실 '정력'을 정의하는 방법이 사람들마다 다 다른 것 처럼... 사실 다 다름. 모두가 동의하는 순수한 OOP는 존재하지 않음.
- 뭐가 뭐를 먹을거다 : 노상관. 업계의 주류 기술은 있을 수 있지만 필요한 곳에 가장 효율적인 방법을 사용하면 됨
- 이 방식만 따르면 된다 : 약팔이하는 것. 단점을 제대로 말하지 못하는 사람은 걸러도 됨. 과학적으로 증명되어야 함
- 프로그래머는 모든 문제의 해법을 미리 배우는게 불가능함 : 중요한건 기본기 **뭐든 완벽한 절대반지는 없다**

## 객체

- 객체란 서로 연관있는 상태와 동작을 가지고 있다(캡슐화)
- 사람들은 기본적으로, 일반적으로 세상을 개체들의 모음으로 본다(어떤 똑똑한 누구는 세상을 개체보다 더 고차원적으로 볼 수도 있지만 일반적인 관점에서 모두가 동의할 수 있을만한 말)

## 객체지향의 특성

### 1. 캡슐화(encapsulation)

- 데이터와 그 데이터에 작용하는 메서드를 하나로 묶음
- 은닉화 : 개체 안에 있는 데이터를 외부로부터 보호. 필요한 데이터만 동작에 제공(외부 : 다른 클래스 다른 개체)

### 2. 상속(inheritance)

- 이미 존재하는 객체를 기반으로 확장된(진화된) 객체를 만드는 방법 => 엄밀히 말하면 객체가 아니라 클래스
- 확장된 객체 : 기존의 객체에 속한 데이터와 동작을 모두 물려 받고, 여기에 다른 데이터나 동작을 추가할 수 있음
- 실용적인 용도 : 코드 중복을 막음. 여러 객체에 공통되는 데이터와 동작을 부모 객체로 만들고 여러 객체는 각각 그 부모 객체를 상속받음. 그후 자기에게만 필요한 데이터나 동작을 추가함

### 3. 다형성(polymorphism)

- 많은 사람들이 OOP의 핵심이라고 여기는 특징. 
- **같은 지시**를 내렸는데 다른 종류의 개체가 **동작을 달리 하는 것**
- 같은 지시: 동일한 함수 시그니처 호출 => 달리 동작, 객체의 종류에 따라 실제로 실행되는 함수 구현 코드가 다름
- 절차적 언어에서 이런 일을 하려면 if문을 사용하려 했음
- 어떤 함수 구현이 실행될때는 실행 중에(런타임 중)결정됨 => 늦은 바인딩
- 일반적인 함수 호출은 이른 바인딩 : 컴파일 중에 결정
- 다형성의 혜택을 받으려면 상속관계가 필요 => 부모 개체에서 함수 시그니처를 선언하고 자식 개체에서 그 함수를 다르게 구현(오버라이딩)
- 실용적인 용도 : 다른 종류의 개체를 편하게 저장 및 처리 가능. 부모 형을 저장하는 배열에 모든 자식 개체를 저장.
- 엄밀히 말하면 이 다형성은 **서브타입 다형성(오버라이딩)** 이라고 함 => 보통 다형성이라고 하면 이거
- 다른 다형성 : OOP랑 상관없는 다형성
  - ad-hoc 다형성 : 함수 오버로딩, 연산자 오버로딩, 함수명은 같은데 매개변수 목록이 다름
  - 매개변수 다형성 : 제네릭. 엄밀하게 말하면 얘도 다형성

### 4. 추상화(abstraction)

- 구체적인 것들이 있고 구체적인 것들에서 공통적 요소를 뽑아서 일반화
- 어떤 것이 동작을 하는데 **내부 동작 방식을 잘 모르는** 상황
- 데이터 추상화 : 개체 사용시 그 안에 정확히 어떤 데이터가 있는지 알 필요는 없음. 대충 뭐하겠지 => 뭐를 하기 위해서 뭐를 사용하는지는 모른다. 캡슐화는 데이터 추상화를 이루는 방법 중 하나
- 다형성을 통한 추상화 : 추상 클래스, 인터페이스 

### 5. 연관(association), 집합, 컴포지션

- 어떤 개체가 제공하는 기능을 다른 개체가 이용하는 관계
- 종종 상속과 비교해서 설명 : 상속은 자식 개체가 부모 개체의 모든것을 내포. 연관은 한 개체가 다른 개체를 참조하는 관계. 실세계에서 개체드링 상호작용하는 모습은 보통 연관에 가까움
- 연관은 집합과 컴포지션으로 나누기도 함. 그냥 퉁쳐서 컴포지션이라고 부르기도 하고
- 컴포지션, 집합 : 여러개의 부품을 조립해서 새 개체를 만드는 방법
- 컴포지션과 집합의 차이 : 컴포지션과 달리 집합은 부품 하나하나가 살아남을 수 있음. 따로 존재(각 객체들이 따로따로 살아남을 수 있음)