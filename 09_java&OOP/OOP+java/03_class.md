# 03_클래스

## 클래스와 개체 생성

- 클래스라는 이름 : 생물학에서 클래스란 '강'. 같은 클래스에 속하는 개체는 비슷한 속성과 동작을 공유
- OOP 클래스 : 새로운 개체를 만들때 사용하는 명세서. 개체는 반드시 클래스로부터 만들어야함. 속성, 동작, 기타
- 붕어빵 틀, 주물이라는 설명이 여기서 나옴
- 딱딱한 모양의 틀

## 클래스 선언

```java
// 접근 제어자(Access Modifier) 붙임
public class Human {
  // 상태 : 멤버변수, 필드, 속성
  public String Name;
  public int age;
  public Sex sex;

  // 동작 : 메서드
  public void walk() {
    // 현재 함수가 호출된 본인 개체
    this.age += 1;
  }

  public void eat() {
    this.age -= 1;
  }

  public void speak() {
    System.out.println("hello friends");
  }
}
```

- 접근 제어자 public : 멤버변수와 멤버 함수 선언시 앞에 붙는 접근 제어자. 외부에서 클래스 내부에 담긴 상태/동작에 접근하는 것을 허용
- 여기서 외부는 다른 패키지를 말함
- public을 안붙였을 경우 컴파일 도중에서 오류가 남. 다른 패키지에서 접근을 못함 일단 public다 붙여야된다고 이해

## 개체생성과 메모리

- 개체를 만드는 법 : 자바에서는 기본 자료형만 스택 메모리에 넣을 수 있음. 그 외에 것들은 못넣음. 클래스는 참조 자료형이기 때문에 메모리 동적할당이 필요(힙영역)

```java
Human adam = new Human()
```

- 객체 : 어떤 대상의 대상체가 되는 것. 근데 물체를 지칭하는 의미에 더 가깝기 때문에 개체라는 말이 더 맞다
- 인스턴스 : 개체를 부르는 또다른 표현. 어떤 것이 한번 발현된 사례

## 개체의 사용

```C
// 구조체
human_t* adam = (human_t*)malloc (sizeof(human_t));

printf("Adam`s age is now %d\n", adam -> age)   // 52685
adam -> sex = MALE;
adam -> name = "Adam";
adam -> age = 20;

printf("Adam`s age is now %d\n")
```

```java
// 클래스
Human adam = new Human();
System.out.printf("Adam`s age is %d%s", adam.age, NEW_LINE);

adam.sex = Sex.MALE;
adam.name = "Adam";
adam.age = 20;

System.out.printf("Adam`s age is %d%s", adam.age, NEW_LINE);
```

- C와의 차이 : 포인터 vs 참조, 개체 생성시 멤버 데이터의 초기화, 도트연산자 다른 의미
- 포인터와의 차이 : 참조형은 사실상 포인터이며, 힙에 위치한 클래스 개체의 주소를 담고 있는 변수가 된다.
- 자바에서는 기본 자료형 제외하면 모두 포인터(참조형). 자바에 포인터가 없다는 말은 거짓말. 포인터 연산이 불가능할 뿐
- 자바에서의 기본 자료형들도 다 클래스가 있긴 있음. 기본 자료형으로 쓸 수 있는 것을 원한다면 다 참조로 바꿔서 사용할 수도 있다.
- C는 원본의 수정 여부를 결정할 수 있으나 자바는 못한다 자바는 도트 연산자를 사용하면 무조건 바뀐다

```c
// 값으로 전달하면 원본이 안바뀜
void increase_age(human_t player, int age) {
  player.age += age;
  age = 0;
}

// 포인터로 전달하면 원본이 바뀜
void increase_age_ref(human_t* player, int* age) {
  player -> age += *age;
  *age = 0
}

int age = 10;

human_t* adam = (human_t*)malloc(sizeof(human_t))

// 포인터의 값을 인자로 넘겨준 상태
increase_age(*adam, age);

// 포인터를 넘겨준 상태
increase_age_ref(adam, &age);

free(adam)
```

```java
// 원본이 바뀜
public void increaseAge(Human player, int age) {
  // 주소를 받아서 주소의 age 값에 접근
  // 값으로 받는게 아니라 사실 C에서의 포인터와 같다
  player.age += age;
  // 여기서 바깥 스코프의 변수인 age는 당연히 바뀌지 않음
  age = 0;
}

int age = 10;
Human adam = new Human();
increaseAge(adam, age)
```

- 자바는 포인터를 명시하지 않으므로 참조형과 값형 변수 선언이 똑같아 보여 헷갈릴 수 있다.

## 개체 생성시 멤버 데이터의 초기화

- C 구조체의 변수는 선언 시 초기화가 안됨
- 메모리에 남아있던 쓰레기 값이 그대로 유지(그냥 이상한 값)
- 자바는 0에 준하는 값으로(0, 0.0, null) 초기화 해줌
- C는 성능 - 메모리 받아와서 다른 값으로 바꿀텐데..왜 굳이? 자바는 실수 안 하는게 더 중요
- 0이 아닌 다른 값으로 초기화해주고 싶으면 멤버변수 선언하면서 값을 할당시키면 된다. 초기값이 0이 아닌것만 그런식으로 해주면 됨
- C에서의 도트 : 구조체의 멤버변수에 접근, -> : 포인터로 참조중인 구조체의 멤버변수에 접근(. + *)
- 자바 : 개체의 멤버에 접근할 때 .연산자 => 모든 개체는 포인터형이기 때문

## 메소드

- 역시 도트연산자로 호출 가능
- 더이상 구조체에 맞는 함수를 헤맬 필요가 없음
- 근데 C처럼 동적 메모리 해제 그런게 없음 => 자바에는 free()가 없음. 메모리를 자동으로 해제해줌 => **GC**
- JVM은 더이상 참조가 없는 개체를 자동으로 메모리에서 해제함
- 그러나.. 가비지 컬렉터가 메모리를 수집하는 시점을 알 수가 없음(언제 GC되는지 정확히는 모름)
- GC되는 상황에서 모든 개체의 사용 여부를 판단하는게 그리 빠른 연산이 아님
- 그러므로 자원이 한정적인 시스템에는 적합하지 않음(이런 경우에는 GC가 발적화가 됨)
- 자동 메모리 관리하에서 발생하는 메모리 누수도 존재 거기에서만 발생하는 메모리 누수도 존재 => 무조건 좋은건 아니고 페이오프가 있다

## 생성자

개체의 모든 시점 무결성을 위해, integrity

```java
// 막 생성된 개체는 유효하지 않은 값을 가지고 있고
// 생성후에 따로 값을 대입 => 개체를 생성할때는 상태가 이상하다
// 그걸 생성자로 가능함
Human adam = new Human();

adam.sex = Sex.Male;
adam.name = "Adam";
adam.age = 20;
```

- 생성자라는 반환값이 없는 특별한 메서드로서(void도 쓸 필요 없음 아예 반환타입을 안적음) 개체 생성과 동시에 멤버변수를 초기화하는 메서드. 
- 함수명은 클래스명과 동일해야한다.

```java
public class Human {
  public String name;
  public int age;
  public Sex sex;

  // 생성자는 반환값이 없다
  public Human(String name, int age, Sex sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
  }
}
```

- 생성자 오버로딩

```java
// 넣는 인자에 따라 다른 초기화
public Human(String name, Sex sex) {
  this.name = name;
  this.sex = sex;
}

public Human(String name, int age, Sex sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

- 코드 중복을 피하는 법 : 생성자 오버로딩에서는 코드 중복이(같은 멤버변수를 초기화할 경우) 일어날 수 있는데, 이런 경우에는 매개변수가 적은 생성자에서 매개변수 수가 많은 생성자를 호출한다. this를 이용해서 다른 생성자를 호출할 수 있다.

```java
// Human(String name, int age, Sex sex) 이랑 같아벌임
public Human(String name, Sex sex) {
  this(name, sex == Sex.Male ? 1: 5, sex)
}
```

- 인자 있는 생성자를 작성해줬는데 적합한 매개변수를 넣지 않으면 컴파일 오류가 발생한다 => 매개변수를 받지 않는 생성자가 없기 때문
- 기본 생성자 : 프로그래머가 생성자를 하나도 안 만들 경우 컴파일러가 자동으로 생성자를 하나 만들어줌. 기본 생성자의 함수 바디는 비어져 있음. **프로그래머가 생성자를 제공하면 기본 생성자는 생기지 않음**
- 왜 개체 생성 후에 값을 대입하면 안 좋은걸까? 결과는 똑같은데 - 응 안좋다
  - 개념상의 문제 : 공장에서 찍어 나온 물건이 속이 비어있다는게 말이 됨?
  - 후조건의 문제 : 개체의 상태는 개체 생성과 동시에 유효 => **만들자마자 사용 가능함을 보장**해야함 - 생성자의 찐의의
  - 사용자를 고려 안 함 : 사용자의 실수를 유발 - 클래스에 있는 어떤 멤버변수를 초기화해야 하는지? 어떤 값으로 초기화해야 하는지? 멤버변수가 추가될 때 기존의 초기화 코드들 업뎃 안하면??
  - 어떤 멤버변수를 초기화해야 하는가? : 멤버변수 중에서 어떤걸 초기화해야 하는지 어떤건 필요가 없는지 잘 파악이 안되는 수가 있음
  - 나중에 멤버변수 수정될때 대응 : 개체 생성 후 계속 정보를 넣어줘야 한다면 멤버변수가 변경될때 클래스 밖에 무슨 다른 정보를 넣어줘야 됨
  - 뭐든 클래스 안에서 하는게 안정성 보장에는 도움이 된다. 초기화에 어떤 계산이 필요할 경우 코드가 중복됨 
- 생성자는 개체를 만들어주는 계약이다. 함수 시그니처와 마찬가지. 호출자와 함수의 분명한 책임 분리
- 외부에서 클래스 내부의 데이터를 알 필요가 없음 => 추상화, 캡슐화

## 접근 제어자

- 생성자 : 객체가 유효한 상태로 만들어짐. 객체가 생성과 동시에 올바른 상태임을 보장
- 그러나 여전히 분탕질 가능 : 생성자로 만든다음에 멤버변수를 이상한 값으로 바꿔서 올바르지 않은 규칙이 적용될 수 있음. 클래스를 많은 사람들이 사용한다면 그런 가능성이 더 커짐 => 이런 제약을 알아서 잘 지켜줄까에 대한 걱정
- 모든 프로그래머들이 엄청나게 많은 클래스에 대한 규칙을 모두 지킬 수 있을까? => No!
- **객체는 자신의 상태를 스스로 책임져야 한다** => 접근 제어자를 통해 이런 일을 할 수 있음. 개체 외부에서 개체의 산태에 직접 접근하는 상황을 막을 수 있음
- 접근제어자 종류 : 뭔가 잘못 사용하고 있다면 컴파일 오류가 발생함
  - public : 누구나 접근 가능, 최상위 클래스에 주로 붙임(내포 클래스는 다른 접근 제어자도 가능)
  - protected : 자식들만 접근
  - 생략 : 같은 패키지에 속한 클래스들만 접근 가능(default, package 접근 제어자)
  - private : 외부 접근 금지. 해당 클래스 내부에서만 접근 가능 내포 클래스인 경우 얘도 가능함. 메서드에 쓸 경우 단독 호출은 안되는데 클래스 내부의 공개된 다른 메서드에서 private 메서드를 호출할 경우 호출할 수 있음
- 일반적으로 : 멤버변수는 private 또는 protected, 메서드는 public. 멤버 변수 접근은 메서드를 통해서만(캡슐화 - 내부의 데이터를 보호, 추상화 - 안에 뭐있는지 모름)
- private 메서드는 클래스 안의 중복되는 코드를 막기 위해서 사용함(걍 함수처럼)
- 생성자에 private을 달수도 있다 => 근데 이런경우는 new를 못씀, 생성자도 멤버함수라서 똑같은 규칙이 적용
- 접근 여부는 객체 기준이 아니라 클래스 기준임. 클래스 내부는 객체 내부가 아님
- 접근 제어자를 안 붙일 경우 : 같은 패키지 안에 있는 클래스끼리 가능 같은 패키지는 public처럼 작동, 다른 패키지라면 private처럼 작동: 그런데 이 경우에는 같은 패키지 안에 있다는 이유만으로 접근이 가능하게 되고 캡슐화를 망가뜨리는 원인이 됨
- public대신 default를 사용해야 된다면 그렇게 해도 됨. OR public이 아닌 내포 클래스를 최상위 클래스로 바꿀때 사용 => 하지만 내포 클래스보다는 별도의 클래스로 분리시키는 것이 요즘 트렌드.. 이때 접근 권한을 패키지 내로 제한하는 것이 public보다는 나음

## getter/setter

```java
// 접근 관리를 제대로 하는 클래스

public class Human {
  private String name;
  private int age;

  public Human(String name, int age) {
    this.name = name;
    this.age = Math.max(age, 0);
  }
}

Human woman = new Human("Janet",  30);
```

- 멤버변수를 일부 공개하고 싶은데 변수에 직접 접근하게 하지는 않고 싶을때 : getter라는 public 함수를 만듬
- 변경을 허락하고 싶은 정보가 있을 경우 : setter라는 public 함수를 만듦
- 왜 멤버변수를 public으로 바꾸지 않나? : OOP의 정신, 객체가 객체 스스로를 책임지게 하기 위해 => set/get은 무조건 만든다
- 함수를 통한 데이터 접근의 객관적인 장점
  - 멤버변수를 저장하지 않고 필요할 때마다 게터에서 계산 가능(computed) 굳이 다른 멤버변수를 만들 필요가 없슴
  - setter에서 추가적인 로직을 실행할 수 있음 => 값이 valid한지 검사한다던가
  - 상속을 통한 다형성 구현 가능
  - 직접 접근은 여러모로 위험
- setter을 절대 만들지 말라는 설이 있음 : 값을 그대로 대입하는 것을 setter로 만드는게 낭비가 아닌가? 멤버변수가 사실상 public으로 바뀌는데?? => 개체 상태는 **개체 스스로 판단해서 바꾸어야 하며** 호출자가 자기 맘대로 바꾸는 것은 구조체 생각과 같다. 이런 관점에서 무조건 만들 필요는 없긴 하다. 모든 것에 setter을 아예 없이 만들수도 있기는 한데... 힘들고 성능상 문제가 생길수도 있다. 뺄수 있으면 빼도 댐.

## 클래스 베스트 프랙티스

1. 멤버변수는 priavate : 안전한 캡슐화
2. 개체는 살아있는 동안 언제나 유효한 상태여야 이상적(생성자) => 그래야 실수를 막을 수 있음
3. getter은 자유롭게 추가 : 사용자가 알 필요 없는 정보는 보여주지 않는게 정석. 보여줘도 근데 큰 문제는 없음 근데 어떤 개체의 레퍼런스를 반환할때는 문제될수도 있음 => C++은 읽기 전용 레퍼런스를 반환할 수 있다고 함
4. setter은 고민 후 추가 : 이상적인 개체 상태 수정은 그 개체의 사용자가 어떤 동작을 지시하고, 동작의 결과로 개체 안에있는 어떤 상태가 바뀌는거 => 즉 객체 스스로 상태를 변경하게끔. 적절한지 판단이 가능

  > - setter은 데이터를 직접 바꾸므로 가능한 피하는게 좋음. 언제나 그럴수는 없긴 하니까 허용
  > - 개체가 불확실한 상태로 되는 것을 막아야함. 
  > - 근데 막 아무생각 없이 무조건 추가하는 경우도 있는데 => 혹시나 모를 미래를 위해 작성하기도 그런데 필요할때 만드셈 걍.

```java
public class Classroom{
  private int[] scores;
  private float mean;

  // 평균을 set하는게 아니라 score을 수정했을때의 결과로 변경
  // setMean(X)
  public boolean setScore(int index, int score) {
    scores[index] = score;
    updateMean();
    return true;
  }
}
```

## 특성 적용

- 클래스 만드는거랑 private : 캡슐화
  - 연관된 데이터와 동작을 한 곳에
  - 외부로부터 데이터 접근을 최대한 불허
- private 멤버변수와 setter/getter => 데이터 추상화
  - 캡슐화가 데이터 추상화를 이루는 방법
  - 사용자는 클래스 속을 알 필요가 없음. 사용자가 함수 속을 알 필요가 없는 것과 마찬가지
  - private 메소드로 중복 코드 없애기