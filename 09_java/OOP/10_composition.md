# 10_상속과 컴포지션

## 재사용성

- 바퀴를 다시 발견하지 말라 : 이미 동작과 상태가 명확한 물체를 다시 개발할 필요가 없다
- 이걸 그냥 사다가 다른 유용한 물체를 만드는게 낫다 => 바퀴를 재발명하려고 시간낭비할 필요가 없는 것이다.
- 재사용성을 생각해서 개발을 하면 설계와 코딩에 드는 시간을 절약할 수 있음
- OO외의 프로그래밍에도 일단 적용되는 올바른 원칙
- 근데 모든걸 다 재사용할 수는 없음 => 미래를 완벽하게 예측할 수 없기때문에 그것에 맞춰 뭔가 만들수는 없다. 아니면 재사용성에 눈이 멀어 잘못된 바퀴를 장착할 수도 있음
- 지금 사용하지도 않는, 또는 정말정말 먼 미래에 사용할만한 코드를 만들수도 있음 => 이것도 쓸데없음
- 약간의 주관이 들어가고 상식의 문제가 되기도 함
- 오토바이로 자동차를 만들거나 하는....
- 주관성이 들어감(재사용성과 유지 관리 사이에서)

## 상속 vs 컴포지션 선택 시 기준

- 둘다 재사용성이 목적. 둘은 호환됨 그리고
- 어떤 경우에 뭘 사용하나?
- 컴포지션 : 어떤 클래스를 만들때 다른 클래스를 부품처럼 사용하는 방식. 부품 클래스들은 만들 클래스에 종속적이다. 만들 클래스 밖에선 크게 의미가 없어짐 `워터 스프레이 (종속성)-> (스프레이 헤드, 스프레이 보틀)`
- 상속 : 어떤 클래스를 만들 때 상위 클래스에서 공통적인 지점들을 먼저 정의하고 상위 클래스를 상속받아 만들고자 하는 클래스를 만든다. 두 클래스 모두 독립적으로 사용할 수 있는 클래스다. `워터보틀 (상속)-> 워터 스프레이`
- **기계상의 차이 때문에 하나를 골라야 할때** : 상속 개체 생성 시 메모리가 하나의 덩어리가 됨. 컴포지션이면 메모리가 여러 덩어리(개체가 메모리 덩어리 하나인데 컴포지션이면 일단 개체가 몇개 더있기 때문에) => 실행 성능에 영향을 미침. 메모리가 여러 덩어리인 경우 좀 느릴수가 있음
  - 상속 모델로 만들면 개체가 한번에 CPU의 캐시 메모리에 들어갈 가능성이 높음(Hit 확률이 높아짐)
  - 컴포지션으로 만들면 개채 안의 부품수 만큼 캐시 메모리로 로딩할 가능성이 높음 => 느려짐. 즉 더 많은 개체를 불러와야함
  - 메모리 할당과 해제에서도 상속이 더 빠름
- **용도 때문에 상속을 고를 수밖에 없을때** : 모든 자식들에게 동시에 명령을 내리고 싶을 경우 - 다형성이 필요할때는 상속 아니면 안돌아감 cat, dog bark
- **관리나 프로세스의 차이** : 컴포지션을 사용하면 컴포지션으로 만들 클래스에 대해 반복되는 메서드를 굳이 또 타이핑해야하는 경우가 생긴다. 상속은 부모의 메서드를 그대로 받기 때문에 중복이 많이 사라짐. 
  - 반대로 상속을 사용하면 불편한 경우도 있음. 깊은 상속관계의 경우 해당 자식 클래스에서 문제가 없는지 모두 확인해야 함. 상속보다는 컴포지션이 느슨한 연결 요소라서 상속보다는 덜 깨짐. 조립성이 좀더 강조되기 때문
  - 이런 강한 연결 요소의 문제는 다형성이나 인터페이스가 좀더 완화시킴
- **일반적인 경우** : 명확하지 않을 경우
  - 상식적으로 생각해야 모든 사람이 서로 이상한 짓거리를 안함
  - 팀간의 규칙을 일반적으로 만들어놓고 따르면 좋음
  - has-a(컴포지션)냐 is-a(상속) 관계에 충실하게 생각할것 => 실제 물체와 연관지어서 생각함

## 상속과 잦은 클래스 변경 

- 실무에서 상속을 포기하는 경우. 기술적인 결정사항이 아니라 비즈니스적인 결정사항이 되는 경우가 있음
- 엔티티 컴포넌트 시스템 : 프로그래머가 컴포지션을 선호하는 예가 됨. 코드 변경 없이 자유롭게 개체를 만들 수 있도록 하는게 목적, 아키텍처 패턴 중 하나
- 상속 체제에서는 뭔가 기능을 바꿀때 어떤 개체를 다른 개체로 상속 구조를 바꿀 수 밖에 없는 상태가 됨 => 프로그래머가 짜증남
- 재컴파일 없이 기획자가 원하는 대로 개체를 조립하는 방법이라면? => 인티티 컴포넌트 시스템
- 실제 플레이어 등의 클래스는 사라지고, 훨씬 모든 오브젝트들을 일반화하는 식으로 개발을 하게됨 => 무슨무슨 컴포넌트

```java
// 가장 일반적인 클래스
public class GameObject {
  private String name;
  private ArrayList<Component> components = new ArrayList<Component>();
  
  public GameObject(String name) {
    this.name = name;
  } 

  public void addComponent(Component component) {
    components.add(component);
  }

  public void update() {
    for (Component component: this.components) {
      component.update()
    }
  }
} 

GameObject player = new GameObject('player');

// 게임 오브젝트 자체는 생성한 객체가 무슨 성질을 가지는지 관심이 없다
// 걍 update로 촤르륵 적용시킬뿐
player.addComponent(new EntityComponent());
player.addComponent(new PhysicsComponent());
player.addComponent(new ControllableComponent());

player.update()
```