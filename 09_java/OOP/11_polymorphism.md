# 11_다형성

## polymorphism

- poly: 다양한, 많은
- morph : 모습이나 형태가 변하다
- 다형성이란 어떤 객체가 다양한 형태로 변할 수 있는 능력

## 예시

- 같은 지시를 내렸는데 다른 종류의 개체가 동작을 달리하는것
- 절차적 언어에서 이런일을 하려면 if문을 사용했어야 했음
- 인터페이스와 추상클래스에 의존함으로써 좀더 명확히 할 수 있음
- 어떤 함수 구현이 실행될지는 실행중에 결정됨 => 늦은 바인딩, 이른 바인딩이라는 것은 컴파일 중에 결정된다는 것
- 다형성의 혜택을 받으려면 상속관계가 필요 -> 부모 개체에서 함수 시그니처를 선언하고, 자식 개체에서 그 함수를 다르게 구현(오버라이딩) : 다형성의 프로그래밍적 핵심
- 다형성은 무조건, 왠만하면 서브타입 다형성

```java
public class Animal {
  public void shout() {
    System.out.println("나는야 동물~");
  }
}

public class Bird extends Animal {
  public void shout() {
    System.out.println("삐약")
  }
}

public class Cat extends Animal {
  public void shout() {
    System.out.println("야옹")
  }
}

public class Dog extends Animal {
  public void shout() {
    System.out.println("멍멍")
  }
}

Animal[] pets = new Animal[3];

pets[0] = new Bird();
pets[1] = new Cat();
pets[2] = new Dog();

// 개체의 실제 형에 따라 알아서 다른 행동을 함 => 다형성
pets[0].shout();
pets[1].shout();
pets[2].shout();
```

```java
// 멍멍을 호출함
// 부모도있고 자식도 있는데 오버라이딩되서 실행됨 - 실제 개체 자료형에 있는
Animal animal = new Dog();
animal.shout()
```

- 어떤 개체 : 부모 클래스형의 변수로 참조중인 개체
- 다양한 형태 : 실제 개체에 구현된 메소드
- 무늬와 실체중 실체를 따라간다

## 무늬와 실체

- 겉보기에는 같은 형 : 상속 관계를 의미함. 부모형으로 자식 개체를 참조할때에 한함. 자식형으로 부모 개체를 참조할 수 없기에 그 반대는 논할 여지가 없
- 상속 없이는 다형성이 작동하지 않는다
- 개체들에 내리는 동일한 명령 : 부모 클래스에서 메서드의 시그니처를 정해줘야함. 그렇지 않으면 부모 클래스형 변수에서 호출 불가 => 오버라이딩을 하려면 부모 클래스에서 해당 메서드가 있긴 있어야함
- 오버라이딩 : 자식 클래스에서 메서드의 구현을 덮어씀/ 오버로딩은 파라미터에 따라 달라지고
- 오버라이딩은 선택사항: 상속을 통해 부모클래스에서 구현한 메서드를 물려받음. 이메 서드에 아무일도 안하면 부모의 동작을 그대로 사용함 자식 클래스가 원할 경우에만 그 구현을 바꿈. 부모의 동작 중에 필요한 것만 고쳐 사용함
- 오버라이딩을 안하면 부모에 있는게 그대로 호출됨
- 부모 메서드랑 합쳐서 호출할 수 있기는 함

```java
public class Animal {
  public void shout() {
    System.out.println("나는야 동물~");
  }
}

public class Sloth extends Animal {
  public void shout() {
    System.out.println("날 내버려 둬~");
    super.shout();  // 무조건 생성자에서는 위에 와야하지만(부모를 먼저 초기화)
    // 다형성으로 부모를 호출하려 할때는 크게 순서가 중요치 않다
  }
}
```

## 다형성의 장점

- 다형성이 없을때 : 객체지향이 원래 자신의 상태와 동작을 자신이 책임진다는 취지에 부합하지 않음
- 각 자료형의 코드가 클래스 안에 들어가니 캡슐화가 더 좋아짐
- 유지 보수성도 높아지고, 새로운 클래스를 추가할때 클래스 코드만 추가하거나, 인터페이스에 의존하면되서 클라이언트가 작성할 코드가 줄어듦
- 다형성을 사용하지 않으면 다른 어딘가에 if문을 추가해야 함 => 책임의 분리가 확실하게
- 코드를 클래스 안에 넣어줘야 한다
- 객체지향에서는 If문이 없어져야 한다 => 이거는 좀 극단적인 주장
- 조건문 없이 객체지향적으로 모든것을 할 수는 있지만, 그렇게까지 할 필요는 없음
- 용납할 수 있는 가성비로 프로덕트가 나와야됨

## 늦은 바인딩 vs 이른 바인딩

- 실행될 메서드를 언제 특정할 수 있나? 오버라이딩되었다면 어떤 메소드가 호출될지 언제 결정될까?
- 다형적인 메서드인 경우에 어떤 메소드가 호출될지는 실행 중에 결정된다
- 늦은 바인딩: 실제로 호출되는 메서드 구현이 프로그램 실행 중에 결정된다는 의미
- 동적 바인딩이라고 함
- 실제로 호출되는 메서드를 실행 중에 누군가가 실에 달아줌

```java
// 이런 경우 인자로 뭐가 올지 모르기때문에 컴파일때는 모른다
// 실행 중에 결정되는 것
public void keepShouting(Animal animal, int count) {
  for(int i = 0; i < count;++i) {
    animal.shout()
  }
}
```

- 이른 바인딩(정적 바인딩) : C에서의 함수의 호출 방식. 어떤 함수 구현을 호출해야 할지가 빌드 중에 결정난다 => 점프(jmp)어셈블리어
- C에서의 늦은 바인딩은 함수포인터로 => 약간... 무언가를 인자로 넣는 방식의 함수라면 동적바인딩적인 느낌이 더 셈
- C에 없는 기능은 하드웨어단에도 없을 확률이 높음
- 가상 메서드 : 자식 클래스에서 동작을 오버라이딩할 수 있는 메서드, 다형적인 메서드

## 바인딩과 성능, 오버라이딩 막기

- 둘 중 성능이 더 빨라질 가능성이 있는 것 - 이른 바인딩 : 컴파일러가 실제로 어떤 함수를 호출해야 하는지 앎. 따라서 컴파일 중에 충분한 시간을 들여 최적화를 할 수 있음. 실행 중에 이렇게 충분한 시간을 사용할 수 없음
- 자바에서도 이른 바인딩이 가능 : 성능과 편의성 사이의 밸런스를 맞추는게 좋음
- 부모 클래스에서의 final : 오버라이딩을 못함, 선언과 동시에 사용할 수 밖에 없는 상수로써 기능
- 자식단에서 맘대로 하는것을 막을때 사용함
- 변수가 아니라 메서드앞에 쓰면 오버라이딩을 못함 => 이렇게 바꾸는 순간 컴파일러는 이른 바인딩을 할 수도 있음.. 오버라이딩될 가능성이 없기 때문
- 변수앞에 붙일때는 constant랑 비슷해짐
- 클래스 앞에 붙는거 : 더 이상 상속을 못함. 자식 클래스가 존재 불가능하고 오버라이딩을 할 수도 없음 => final은 컴파일러가 검사해주는 것임
- final을 기본적으로 붙이는게 코드표준이는 경우가 있음 : 가능하면 모두 붙이고 나중에 상속이나 변경해야 하는 상황이 오면 final을 빼도 됨 => 자바스크립트의 const

```java
public class Athlete {
  public final int getHeight() {
    return this.height
  }

  public final double getWeight() {
    return this.weight
  }
}
```
