# 14_의존성, 결합도, 디커플링

- 뭘 어떻게 더 사용해야 하나? 
- 인터페이스를 사용하는 효용이란?

## 의존성

- 소프트웨어 모듈 A가 제대로 작동하려면 다른 모듈 B가 필요한 경우
- 클래스 A가 B에 의존한다면 => B가 없으면 A는 작동이 안됨. A가 없어도 B는 작동이 안됨
- 의존성이 있어야 좋은 설계 : 각 클래스의 목적이 뚜렷하다는 의미가 됨. 캡슐화가 잘 되어있다는 의미이기도 하고 클래스를 재사용할 수 있다는 의미도 됨 => 함수 재사용성과 마찬가지, 의존성을 완전히 없애려면 프로그램 전체를 함수 하나에 작성하면 됨(에바 모놀리틱)
- 의존성이 나쁜 것만은 아님
- 의존성과 결합도는 다른 용어(결합도는 좀 나쁜거)

## 결합도

- coupling
- 원래 의미는 두 소프트웨어 모듈 간 **상호 의존성** 정도
- 원래는 : 클래스 A가 클래스 B에 의존하고, B도 A에 의존해서 둘중 하나도 독자생존이 불가능한 상황
- OO에서는 A가 B에 의존하는 상황에서 B를 변경할때 프로그램이 잘 작동하는가? => A의 내부를 변경 안해도 제대로 동작(느슨한 결합도), A의 내부를 변경해야만 제대로 동작(강한 결합도)
- 의존은 없을 수 없지만 결합도의 문제는 생길 수 있음
- 요약 : B코드 변경 시 A코드도 변경해야 하면 결합도가 높은 것

## 표현

- 결합도 관련 : A가 B에 심하게 의존한다, 결합도가 높다, 결합도가 낮다
- 의존성 : 의존한다다, 의존성이 있다
- 높은 결합도는 나쁘지만 의존성 자체가 나쁘다는 말은 못함 => 의존성이 아예 없는게 나쁜것
- 결합도를 줄이는 행위 : 디커플링, 결합도를 줄인다.
- 의존성을 제거하는건 말이 안됨 => 근데 뭐 대충 결합도를 줄인다는 느낌으로 자주 사용

## 결합도의 판정

- 의존하는 클래스에 뭐 생성자에 인자가 추가되었을 때 => 의존 피의존 둘다 바뀌어야함 => 결합도가 높음
- 줄이는 방법 : A는 B속이 어떻게 구현되어 있는지 모름 => 느슨한 커플링

## 의존성 주입(Dependency Injection) + 의존 관계에서의 결합도

- 의존하는 얘를 직접 넣어줬다 => 의존하는 얘에 대해 깊게 알 필요가 없음
- 생성자 주입 : 피의존 클래스 생성자에 인자로 다른 객체 생성자 넣어주는 것
- setter 주입

```java
public final class Robot {
  private int hp;
  private Head head;

  public Robot(int initialHp, Head head) {
    this.hp = initialHp;
    this.head = head;
  }

  public Head getHead() {
    return this.head;
  }

  public void setHead(Head head) {
    this.head = head;
  }
}

Head head = new Head(45);
Robot robot = new Robot(300, head);
// 세터로 생성자를 주입 => 생성자 주입 생략 가능
// 개체의 유효한 상태에 해가 될 수 있다
// 다른 개체를 세터로 바꿔끼울수도 있다 => 캡슐화가 망가짐
robot.setHead(new Head(60))
```

- 미리 Head를 만들어 전달하는게 불편할 수도 있음(head를 따로 그렇게 넣어준다는 것이)
- 장단이 있음 : 결합도를 낮추지만 편의성을 잃었음 => 밸런스를 잘 맞추는게 좋음

## 상속 관계에서의 결합도

- 상속 관계에서도 비슷한 일이 일어날 수 있음
- 의존성 주입을 해야하는 상황에서 넣는 생성자가 뭔가 상속이 된거라면, 부모 클래스 타입을 주는게 더 결합도가 적음(모두 같은 부모를 상속)

```java
// 다형성을 사용해서 결합도를 줄이는 것
public final class Robot {
  private int hp;
  private Head head;
  // 무슨 Head든 괜찮음 => 추상 클래스에 의존함
  public Robot(int initialHp, Head head) {
    this.hp = initialHp;
    this.head = head;
  }
}
```

- 의존성은 없어진게 아님
- 인터페이스도 마찬가지 : 추상 클래스의 특별한 형태이기 때문에. 둘다 구체 클래스보다 좀더 일반적인 형태, 자식 클래스를 교체해도 그 개체를 사용하는 코드를 바꿀일이 없음
- 구체가 아니라 인터페이스에 의존하라는 말이 이래서 나오는 것임

## 디커플링을 해야할 때

- 단순한 구조에서는 실익이 크지 않음 : 뭔가 바뀌더라도 한두군데만 고치면 되고 컴파일러가 일찍 문제를 잡아주니 큰 문제는 없음. 변경이 불가능한 상황이 아니라면 굳이 커플링을 줄일이유가 없음
- 인기가 많아서 다른 클래스 5000개가 막 어던 클래스를 사용하고 있으면 그건 결합도 낮추는게 진짜 필요해지는 것임 => 아예 의존성을 줄이는 것도 
- 함수 포인터(인터페이스)디커플링의 좋은 예
- 디커플링은 유연성과 재사용성을 높임 => 추상화 업, 미래의 변화에 대비하고 있다는 이야기도 됨
- 단점: 직관적이지는 못함 => 필요한 정보를 한번에 못찾음 인터페이스가 너무 일반적인 내용이라서 특정 인스턴스가 들어올때에 특화된 기능을 추가할때 망설여짐. 호출자를 찾는것도 헷갈릴 가능성이 높아짐 => 회사의 어떤 업무 프로세스와 결합하면 결국 해결이 안되는 경우도 비일비재
- 또 다른 단점 : 결합도를 높이더라도 내부를 알아야 좋을 때도 있다. 클래스를 아우르는 방식으로. 좀더 구체적인 컬렉션 클래스를 사용하면 최적화가 가능하긴 함 => 성능이 중요한 경우에는 일반화와 추상화가 비효율적일 수 있음

## 모든 것이 인터페이스여야 하나?

- 이상한 소리 : 다른 클래스에 속한 개체의 메서드를 절대로 직접 호출하면 안된다. 모든 것을 인터페이스로 만들어라. 모든 클래스를 직접 호출하지 말아라
- 디커플링이 언제나 제일 중요한 것이냐? OO에서 결합도를 낮추는게 항상 능사인가? => 아까 봤듯이 아님
- 인터페이스를 implement하는게 더 타이핑적으로나 귀찮아질 가능성이 높아질수도 있음
- 나중에라도 다형성이 생길 것 같아서? => 이른 추상화
- 인터페이스와 구현의 1:1은 이상한 일임 : 다형성이 필요 없는데도 클래스마다 인터페이스를 만드는 꼴은 좋지 못함
- 인터페이스의 정의 : 상태도 메서드 구현도 없는 순수 추상 클래스. public 메서드 시그니처만 모아 놓은 것
- 다형성 없는 인터페이스는 없다
- 극단적 이상한 이야기 : 인터페이스는 명령을 나열한 것이므로 OO의 기본이고, 사람처럼 이해하는게 아니라 커플링을 줄이는 것이 목적이다.
- 구현이 아니라 인터페이스를 대상으로 프로그래밍하라 : 이게 GOF 책에 나오는 말인데, 무조건 자바의 interface를 사용하라는 이야기가 아님. 들어갈수 있는게 하나라서 매우 직관적이고 문제가 없는 상황에도 굳이 Interface를 낄겨해서 사용하게 되버림 => 근데 그렇게 사용하면 다형성이 없어짐 걍 맹목적
- 상속을 따라서 자식이 따라야하는 공통 인터페이스를 정의하는 것도 중요하다 => 다형성이 공통 인터페이스에 의존하기 때문
- 일반적인 인터페이스의 정의 : 부모 클래스의 다형적인 메서드 시그니처(추상 클래스도 괜찮고..함수 포인터도 괜찮고...)

## 인터페이스에 대해 프로그래밍하라는 의미

- 위에 있는 클래스를 사용할수록 결합도가 줄어든다는 의미
- 함수처럼 내부를 알려고 하지말고 시그니처로 움직이라는 이야기가 클래스에서 적용된 것
- 가장 중요한 목표는 실수 예방하는 것 : 소프트웨어 개발은 협업 환경이기 때문에, 그나마 모두가 직관적으로 이해할 수 있는 방법은 실수를 줄임 => 주관성이 적기 때문
- 가장 중요한 목표는 실수 예방, 객관적을 최대한 높이는 것이 중요함
- 다형성, 포인터, 재귀함수가 이해하기 어려운 이유 : 한단계 건너 뛰어서 생각해야 하니 직관적이지 않음

## 미래 예측

- 불변의 규칙을 정해놓는 것이 도움이 될 수 있음 => 요즘은 발전 속도를 좀더 중시
- 라이브러리만 만드는 팀이라면 : 라이브러리를 고칠 때마다 클래스 혹은 인터페이스의 public 메서드 시그니처가 바뀜 => 다른 팀이 빡침
- 이때 인터페이스와 커플링하면 조금 더 나음 : 인터페이스가 바뀌지 않을 가능성이 조금 더 높기 때문에 => 추상화 레벨을 높일수록 조금 더 나아짐
- 핵심은 클라이언트와의 약속 : 결합도 문제 뿐은 아니고, 무엇을 변경하고 무엇을 안 변경할지 약속을 해주는게 좋음 : 어떻게 깨지는 것을 방지할 것인지 근데 업데이트 속도가 계속 늘어날수록 사람들도 깨지는 것에 익숙해지고 => 깨졌을 때 후속 업데이트가 계속 되는것도 익숙하다.
- 쉽게 바꿀 수 있다면 미래를 예측하지 않아도 좋음 : 시스템이 크지 않거나 클라이언트가 많지 않거나 여러 버전을 특정 기간동안 지원할 수 있거나 => 경험이 쌓일수록 인사이트가 있을듯
- 인터페이스를 사용했을 때 실익이 커지는 경우라면 변화에 대한 대비를 그렇게 하는게 더 낫다.