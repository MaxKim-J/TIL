# React, Vue 디자인패턴

MVVM, FLUX

## 일단 둘다
- 프레임워크가 아니라고 할 수 있다는 점을 좀 짚고 넘어가자
- 그냥 기준이 참 모호하고 말장난같지만 그냥 내생각에 구분법은 **강요하는 구조가 있고 그걸 위주로 코드가 돌아가냐**는 것
- 제어의 역전 : 프레임워크 자체가 제어권을 가지고 있는 프레임워크, 개발자가 제어권을 가지고 있는 라이브러리 사용
- 개발자가 들어가서 짜느냐(프레임워크), 개발자가 가져와서 짜느냐(라이브러리)
- Django를 생각해보면, 구현해야할 디렉토리안에 뭘 넣어줘야되고 이런게 매우 강제되어 있는 MVC 프레임워크다(model, view 함수(컨트롤러), 템플릿(뷰) - 구조도 딱딱 떨어진다)
- 근데 리액트나 뷰는 그저 html에서도 스크립트 안에 임포트해오면 돌아간다(특히 vue는 그렇게 활용해도 전혀 상관이 없게 설계되었다) 
- 개발자가 정한 구조에 입맛대로 불러와서 사용하면 되는거라서 라이브러리에 더 가깝다
- 그래서 사실 아래에서 이야기할 이 라이브러리들의 디자인 패턴을 논한다는게???약간 좀 거시기한 경향이 있다.

## Vue.js
![](https://github.com/namjunemy/TIL/blob/master/Vue/img/01.PNG?raw=true)
- MVVM 패턴의 viewModel 레이어에 해당하는 view단 라이브러리
- 모델과 뷰 사이에 뷰모델이 위치
- 2 way data binding(양방향 데이터 바인딩)
- 컴포넌트간 통신의 기본 골격은 react의 단방향 데이터 흐름과 유사함(물론 뷰에서만 역방향이 가능)
- 뷰모델 : 모델과 뷰 사이에 인터페이스 역할을 한다,  뷰 모델은 모델의 데이터를 뷰에 바인딩하고 명령어를 사용하여 UI동작들을 다룸, 뷰는 뷰 모델의 프로퍼티에 제어값을 바인딩하여 차례대로 모델 객체에 있는 데이터를 노출시키게 된다.

### 양방향 데이터 바인딩
- data binding : 모델과 뷰의 자동 동기화, 모델에 있는 값이 바뀌면 view도 바뀐다
- 뷰 <-> 데이터 : 데이터에 있는 값이 뷰에 나타나고 이 뷰의 값이 바뀌면 데이터의 값도 바뀐다
- `{{}}`은 화면에 뷰모델에 있는 데이터를 보여주는데 ->
- `v-model`은 뷰에서도 뷰모델을 변경할 수 있게 해준다 <-
- v-model 걸어놓고 input에 값 입력하면 실시간으로 바로 변한다


### vs 단방향 데이터 흐름
- 인풋에 텍스트 값 입력한다고 해서 바로 변하진 않구 이벤트 처리 메소드가 submit을 했을 때야 state값이 들어간다
- 데이터 => 뷰, 데이터의 값이 변하면 바로바로 업데이트 == 데이터에 값이 변해야 뷰가 업데이트
- React의 경우 v-model처럼 바로 state를 업데이트하지 못하고 함수를 매개해야함
- 실행부 자체 내에서 데이터의 변화를 감지하지 않으며 데이터에 변화가 오게 되면 특정 함수를 실행시킴으로써 DOM객체 갱신
- 리액트는 앵귤러나 뷰처럼 단순한 양방향 데이터 바인딩 방식을 지원하지는 않는다고 봐야 한다

## React.js
- MVC가 아니구... => mvc는 모델과 뷰의 의존성때무네 거대한 시스템에 어울리지 않는다는 결론
- 뷰랑 모델이 시도때도없이 서로 바꿔버리면 넘 복잡해
- mvc 대안 : 데이터 흐름이 **단방향**인 시스템 아키텍쳐를 만들자!! =>FLUX

### FLUX
![](https://1.bp.blogspot.com/-bqf4ngrwMFc/Vw8h35ikVrI/AAAAAAAABtc/ZlBewhe66r0DiR25hV84hBDX-6iu_VL6QCKgB/s1600/flux.png)
- **만고의 진리 : 무조건 모델(store)을 통해서만 뷰가 바뀐다!!!!!!!!!!**
- 아무래도 mvc와 가장 큰 차이는 데이터가 단방향으로 흐르고 있다는 것일듯
- store:model과 대응
- dispatcher : 모든 데이터를 관리하는 controller 역할, action이 시작될때 어떻게 store가 업데이트 되어야 하는지 결정
- view : store가 바귀면 같이 바뀜
- 단방향: 데이터 계층이 **자기가 영향을 미치는 View 업데이트 완료 후에 다음 작업을 진행**
- 모델 데이터가 바뀐다 => view가 바뀐다(이게 다!)
- view에서 무슨 인터렉션 발생=> 디스패처 => 모델을 변경 => 뷰가 바뀐다
- 실질적 : 이벤트 발생(인터렉션) => 함수 실행 => 함수가 store(state)를 변경 => 뷰가 바뀜