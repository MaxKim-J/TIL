# HTTP 메시지

## 정의
- HTTP에서 교환하는 정보
- 리퀘스트 메시지, 리스폰스 메시지
- 복수 행 데이터로 구성된 텍스트 문자열
- 크으게 구분하면 : 메시지 헤더/개행문자/메시지 바디
- 라인 + 헤더 + 개행문자 + 바디

## 메시지 헤더 + 바디
- 클라이언트나 서버가 리퀘스트나 리스폰스를 처리하기 위한 정보가 들어 있음
- 이러한 정보의 대부분은 클라이언트를 이용하는 사용자가 직접 볼 필요는 없구

### 메시지 헤더에 들어가는 데이터
- 리퀘스트 라인 : 리퀘스트에 사용하는 메소드와 리퀘스트 URI와 사용하는 HTTP 버전이 포함(맨 첫줄)
- 상태라인 : 리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전이 포함된다(맨 첫줄)
- 헤더필드 : 리퀘스트와 리스폰스의 여러 조건과 속성을 나타내는 각종 헤더 필드 포함(찐 헤더), 일반 헤더 필드, 리퀘스트 헤더 필드, 리스폰스 헤더 필드, 엔티티 헤더 필드 + 쿠키가 포함되기도(필드라서 키값 쌍으로 되어있음 :으로 구분)

### 헤더 필드 종류
- 일반적 헤더 필드 : 리퀘스트, 리스폰스 둘 다 사용되는 헤더
- 리퀘스트 헤더 필드 : 리퀘스트에서 쓰는 헤더
- 리스폰스 헤더 필드 : 리스폰스에서 쓰는 헤더
- 엔티티 헤더 필드 : 리퀘스트 리스폰스에 포함된 엔티티에 사용되는 헤더(주로 content가 붙은 것들)

## Message 구조

### 리퀘스트/상태라인(맨 첫줄)
```bash
GET / HTTP/1.1 # 리퀘스트 라인
HTTP/1.1 200(상태코드) OK # 상태 라인
```
- 리퀘스트 라인 : 리퀘스트 메소드 (GET, POST 등등), 요청 URL, HTTP 버전
- 상태 라인 : HTTP 버전, 상태 코드, 상태 메시지

### 공통 헤더 + 엔티티 헤더
- Date : http 메시지가 만들어진 시각
- Connection : 프록시에 더이상 전송하지 않는 헤더 필드를 지정하고 지속적 접속을 관리, 접속 유지가 디폴트인데 서버에서 명시적으로 접속을 끊고 싶을 때는 여기에 Close 해준다. 또는 keep alive 
- content-length : 요청과 응답 메시지의 본문 크기를 바이트 단위로 표시
- cache-control : 디렉티브 명령을 사용해 캐싱 동작을 지정 
- **content-type** : 바디의 컨텐츠 타입과 문자열 인코딩 방법 명시
- content-language : 사용자 언어

### 리퀘스트 헤더
**꼭 알아야될 거 같은거 위주로 다 뽑아봄**

- host: 서버 도메인 이름
- **user-agent** : 리퀘스트를 생성한 브라우저와 유저 에이전트의 이름을 전달
- accept : 현재 클라이언트가 허용할 수 있는 파일 형식. 처리할 수 있는 미디어 타입과 미디어 타입의 상대적인 우선 순위 전달(서버쨩 이런걸 보내줬음 좋겠어), accept-encoding, accept-charset, accept-language
- cookie : 웹 서버가 클라이언트에 쿠키를 저장해 놓았다면 해당 쿠키의 정보를 이름-값 쌍으로 웹서버에 전송
- origin : post 요청을 보낼때 요청이 어느 주소에서 시작되었는지를 나타내는데, 이때 보낸 주소와 받는 주소가 다르면 cors이슈 발생
- **authorization** : 인증 토큰을 서버로 보낼때 사용하는 헤더. 토큰이 없으면 거절당함

### 리스폰스 헤더
- server : 웹서버 정보
- Access-Controll-Allow-Origin : 교차 출처 리소스 공유. 이 응답이 리퀘스트에서 주어진 origin으로부터 요청 코드와 공유될 수 있는지 나타냄. 요청 호스트와 응답 호스트가 다르면 CORS 에러가 발생. 서버에서 응답 메시지 저기 헤더에 클라이언트 주소를 적어주면 에러가 발생 안함
- allow : 받을 수 있는 요청 메소드
- content-security-policy : 다른 외부 파일들을 불러오는 경우 차단한 소스와 불러올 소스를 명시

### 리퀘스트/리스폰스 바디
- 모든 응답에 본문이 들어가진 않음(응답은 상태코드에 따라, 요청은 요청 메소드에 따라)
- content type으로 정의한 본문 text/html, multupart/form-data, json, www-url-form-encoded 뭐 이런저런거 있음
- 일부 요청은 업데이트를 위해 서버에 데이터를 전송(POST), 그 데이터는 본문에 들어감
- form 형태(url encoded)
- json 형태
- 멀티파트 형태(이진파일)

## 또 따로 정리할 것
- 헤더의 cache-control과 디렉티브들, content-incoding과 그 방법들
- 쿠키세션
- https