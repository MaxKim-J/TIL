# 자바스크립트 이벤트

## 정의

- 이벤트는 어떤 사건을 의미함. 사용자가 일으키는 어떤 사건, dom요소와 관련이 생긴다.
- 이벤트가 발생하는 시점이나 순서를 사전에 인지할 수 없으므로 일반적인 제어 흐름과는 다른 접근 방식이 필요. 이벤트가 발생하면 누군가 이를 감지할 수 있어야 하며 그에 대응하는 처리를 호출해주어야 한다.
- 브라우저는 이벤트를 감지할 수 있으며 이벤트 발생 시에는 통지해 줌 -> 이 과정을 통해 사용자와 웹페이지는 상호작용이 가능하게 됨
- **이벤트 핸들러** : 이벤트가 발생하면 그에 맞는 반응을 해야 함, 이 과정을 통해 사용자와 웹페이지는 인터렉션 하게 됨

## 이벤트 드리븐, 이벤트 루프

- 브라우저는 단일 쓰레드에서 이벤트 드리븐 방식으로 동작
- 쓰레드가 하나라는 얘기가 곧 하나의 작업만을 처리할 수 있다는 것을 의미, 하지만 실제로 동작하는 웹 애플리케이션은 많은 task가 동시에 처리되는 것처럼 느껴짐 
- 자바스크립트의 동시성을 실현하게 해줄 수 있는 것이 => **이벤트 루프**
![사진](https://poiemaweb.com/img/event-loop.png)

- 콜스택(호출스택) : 작업이 요청되면(함수) 요청된 작업은 순차적으로 콜스택에 쌓이고 순차적으로 실행됨. 자스는 단 하나의 콜스택을 사용하기 때문에 해당 task가 종료되기 전까지는 다른 어떤 task도 수행 못함
- 힙영역 : 동적으로 생성된 객체 인스턴스가 할당되는 영역
- 이벤트 큐 : **비동기 처리의 콜백 함수, 비동기식 이벤트 핸들러, timer 함수**의 콜백 함수가 보관되는 영역, 이벤트 루프에 의해 특정 시점에 순차적으로 콜스택으로 이동되어 실행.
- **이벤트 루프** : 콜스택 내에서 실행중인 task가 있는지 그리고 이벤트큐에 태스크가 있는지 반복하여 확인. 만약 콜스택이 비어있다면 **이벤트큐의 태스크가 콜 스택으로 이동되고 실행.**
- 이벤트를 포함한 비동기 요청 처리는 자바스크립트 엔진을 구동하는 환경, 즉 브라우저가 담당

### 예시

- addEventListner : 호출시 콜백이 바로 실행되지 않고, **해당 이벤트가 발생했을 때 이벤트 큐로 이동한 후 콜스택이 비어졌을 때 이동되어 실행**
- setTimeOut : 콜백함수가 즉시 실행되지 않고 지정 대기시간만큼 기다리다가(web api) **tick이벤트가 발생하면 콜백이 태스크 큐로 이동한 후 콜스택이 비어졌을 때 콜스택으로 이동하여 실행**

## 이벤트 종류

내가 이걸 언제 다 써보겠어.. 한번 다 써보자  

- UI Event : load, unload, error, resize, scroll, select
- Keyboard Event : keyDown, keyup, keypress
- Mouse Event : click, dbclick, mousedown, mouseup, mousemove, mouseover, mouseout
- focus Event : focus, blur
- Form : input, change, submit, reset
- clipboard : cut, copy, paste

## 이벤트 핸들러 등록

### 방식

#### 1. 인라인 이벤트 핸들러

- html 요소의 이벤트 핸들러 어트리뷰트에 이벤트 핸들러를 등록한다 => HTML과 자스는 관심사가 다르므로 분리해야함, 좋지 않은 방식
- 알고 있겠지만 CBD방식 리액트 뷰에서는 인라인 이벤트 핸들러 방식으로 이렇게 처리함. 여기서는 HTML,CSS,자스 모두 뷰를 구성하기 위한 구성요소로 보기 때문에 관심사가 다르다고 생각하지 않음
- on으로 시작하는 이벤트 어트리뷰트의 값으로 함수 호출을 전달한다, 이것도 알겠지만 이벤트 핸들러 프로퍼티 방식에서는 함수 호출이 아닌 함수를 전달한다

#### 2. 이벤트 핸들러 프로퍼티

- 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만을 바인딩한다(on 뭐시기 써서)

#### 3. addEventListner 메소드 방식

- 그냥 이거 쓰면 된다
- 하나의 이벤트에 대해 하나 이상의 이벤트 핸들러를 추가할 수 있다
- 캡처링과 버블링을 지원한다
- HTML요소뿐 아니라 모든 돔 요소에 대해 동작한다. 브라우저는 웹 문서를 로드한 후 파싱하여 돔을 생성하기 때문
- IE9이상이란다
- 대상 돔을 지정하지 않으면 전역객체인 window에 이벤트 리스너를 바인딩한다 => 돔문서를 포함한 브라우저의 윈도우에서 발생하는 클릭 이벤트
- 이벤트 리스너에 선언한 함수를 전달하는게 낫다

## 이벤트 핸들러와 this

- addEventListner메소드에서 지정한 이벤트 핸들러는 콜백함수이지만(즉 function 키워드로 전역객체에 바인딩이 될 것이지만) 이벤트 핸들러 내부의 this는 **이벤트 리스너에 바인딩된 요소**를 가리킨다. (내부 동작으로 인해)
- 이것은 (뒤에서 살펴볼) 이벤트 객체의 currentTarget 프로퍼티와 동일하다.

### 참고) this 추론

- 그냥 다른 언어들은 인스턴스 자신을 가리키는 것으로 사용(자바의 this, 파이썬의 self)
- function 키워드면 무조건 window에 this 바인딩 => 화살표함수는 자신이 호출된 상위 객체의 this를 바인딩
- 프로퍼티 호출이면 . 앞에 있는 객체에 this 바인딩(객체)
- 생성자 함수의 this는 인스턴스를 가리킴
- 이벤트리스너 콜백 내부의 this는 이벤트리스너에 바인딩된 요소를 가리킴 => 콜백함수는 로직에 따라서 어디에 바인딩되는지가 좀 달라짐

## 이벤트 흐름

![캡버](https://poiemaweb.com/img/eventflow.svg)

계층적 구조에 포함되어 있는 HTML 요소에 이벤트가 발생할 경우 연쇄적 반응이 일어나 이벤트가 전파되는데 전파 방향에 따라 버블링과 캡처링으로 구분한다. 약간 메아리치는거 같음 에코잉..

- **버블링** : 자식요소에서 발생한 이벤트가 부모 요소로 전파되는 것
- **캡처링** : 자식 요소에서 발생한 이벤트가 부모 요소부터 시작하여 자식 요소까지 도달하는 것
- 이벤트는 캡처링으로 시작하여 버블링으로 종료된다 위=>아래
- addEventListner 메소드의 세번째 매개변수에 true를 설정하면 캡처링으로 전파되는 이벤트를 캐치하고 false나 미설정하면 버블링으로 전파되는 이벤트를 캐치
- 일반적으로 이벤트는 버블링만 캐치 == 계층구조를 가지고 있는 돔 트리에서 이벤트가 발생한 하위 객체에서부터 상위 객체까지 이벤트가 올라가면서 처리된다 => 이벤트가 올라가면서 있는 모든 상위 객체에도 감지된다
- 캡처링이 버블링보다 **먼저** 동작한다는걸 기억해두자

## 이벤트 객체

- event객체는 이벤트를 발생시킨 요소와 발생한 이벤트에 대한 정보를 제공하는 객체
- 이벤트가 발생하면 event객체는 동적으로 생성되며 이벤트를 처리할 수 있는 이벤트 핸들러의 **첫번째** 인자로 전달된다.
- 이벤트 핸들러에 event 객체는 암묵적으로 전달하지만 실제적으로 콜백에서 사용하려면 이벤트 객체를 전달받을 첫번째 매개변수를 명시적으로 사용해야 함(e)

### 이벤트 객체의 프로퍼티

#### event.target
실제로 이벤트를 발생시킨 요소, 콜백에서 요소를 바로 수정할 수도 있다  
```js
function hide(e) {
    e.target.style.visibility = 'hidden';
    // 동일하게 동작한다.
    // this.style.visibility = 'hidden';
}

document.getElementById('btn1').addEventListener('click', hide);
document.getElementById('btn2').addEventListener('click', hide);
```
이벤트 위임을 사용해서 상위 노드에다가 이벤트리스너를 걸어주면 굳이 이벤트 리스너 두 개를 따로 걸어줄 필요가 없어진다. 어짜피 버블링을 통해 잡아준다.

```js
<div class="container">
    <button id="btn1">Hide me 1</button>
    <button id="btn2">Hide me 2</button>
</div>

 function hide(e) {
      // e.target은 "실제로" 이벤트를 발생시킨 DOM 요소를 가리킨다. => btn이나 컨테이너
      e.target.style.visibility = 'hidden';
      // this는 이벤트에 바인딩된 DOM 요소(.container)를 가리킨다. 따라서 .container 요소를 감춘다.
      // event.target이 this와 항상 일치하지는 않는다
      // this.style.visibility = 'hidden';
    }
    container.addEventListener('click', hide);
```

#### event.currentTarget

- 이벤트에 바인딩된 DOM요소, addEventListner 앞에 기술된 객체, 이벤트 핸들러 함수 내에서 currentTarget과 this는 언제나 일치. (이벤트 핸들러를 걸어준 그 돔요소)
- target이 될 수 있는 것 : 이벤트 핸들러를 걸어준 노드와 그 노드의 하위 노드들을 포함, 하위 노드가 target이었을 경우 this와 달라짐.
- currentTarget이 될 수 있는 것 : 이벤트 핸들러를 걸어준 그 노드 뿐. this와 항상 같음.

#### 그외
- Event.type : 이벤트의 종류를 나타내는 문자열을 반환
- Event.cancelable : 요소의 기본 동작을 취소시킬 수 있는지 여부
- Event.eventPhase : 이벤트 흐름 상에서 어느 단계에 있는지 반환, 0:이벤트 없음, 1:캡처링, 2:타깃, 3:버블링

## 이벤트 위임
- 돔노드 하나하나에 이벤트 바인딩하려면 귀찮다
- 동적으로 무슨 요소가 추가되는 경우 아직 추가되지 않은 요소는 DOM에 존재하지 않으므로 이벤트 핸들러를 바인딩할 수 없다. => 이벤트 위임 사용
- **이벤트 위임** : 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신에 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법. 
- 이는 이벤트가 이벤트 흐름에 의해 이벤트를 발생시킨 요소의 부모 요소에도 영향(버블링)을 미치기 때문에 가능 => 버블링 단계에서 올라오면서 잡아냄
- 실제로 이벤트를 발생시킨 요소는 Event.target에 기록되어있다

## 기본 동작 변경

이벤트 객체는 요소의 기본 동작과 요소의 부모 요소들이 이벤트에 대응하는 방법을 변경하기 위한 메소드를 가지고 있음

### event.prevendDefault()

- 폼을 submit하거나 링크를 클릭하면 다른 페이지로 이동. 이와 같이 요소가 가지고있는 기본 동작을 중단시키기 위한 메소드가 preventDefault()
- 요소의 기본 동작 중단시키기

### event.stopPropagation()

- 한 요소를 이용하여 이벤트를 처리한 후 이벤트가 부모 요소로 전파(버블링)되는 것을 막기 위한 메소드, 부모 요소에 동일한 이벤트에 대한 다른 핸들러가 지정되어 있을 경우 사용
- 상위 돔 노드가 하위 돔 노드와 같은 이벤트를 처리해야하는데 콜백은 다르게해서 다른 식으로 처리해야할 때 사용함
- 상식적으로 하위에 있는 이벤트리스너 건 돔 객체들에 대해서 다 콜백에 넣어줘야 할듯?