# 실행 컨텍스트 + 호이스팅

2020.02.01  
공부했지만 한 번 정리

## 정리
실행 컨텍스트 : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체  
실행 컨텍스트가 활성화 되는 시점에 - `1.호이스팅, 2.외부 환경 정보 구성 3.this를 설정`
호이스팅 : 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리는 것  

## 실행 컨텍스트
### 콜스택
동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고  
이를 콜 스택에 쌓아 올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련된 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장  
동일한 환경 : 전역공간, 함수 등  
흔히 실행하는 컨텍스트를 구성하는 방법은 - 함수를 실행하는 것

### 작동방식
1. 자바스크립트 코드를 실행하는 순간 전역 컨텍스트가 콜 스택에 담김
2. 함수를 만나면 함수에 관련된 환경 정보를 수집해서 함수에 해당하는 실행 컨텍스트를 생성한 후 콜 스택에 담음(함수를 호출한 시점에)
3. 다 담은 후에는 스택의 가장 윗부분부터 실행하게 됨
4. 함수의 실행이 종료되면 실행된 컨텍스트가 콜 스택에서 제거됨

스택 구조를 잘 생각해보면 한 실행 컨텍스트가 콜스택 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점  
어떤 실행 컨텍스트가 활성화될 때 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는데 **필요한 환경 정보들을 수집**하여 실행 컨텍스트 객체에 저장한다

### 무슨 정보들이 담기나
- VariableEnvironment : 현재 컨텍스트 내의 식별자에 대한 정보 + 외부 환경 정보. 선언 시점의 LexicalEnvironment의 스냅셧으로 변경사항은 반영되지 않음
- LexicalEnvoironment : 처음에는 VE와 같지만 변경사항이 실시간으로 반영됨
- ThisBinding : this가 바라봐야 할 대상 객체

#### VariableEnvironment(VE)
VE에 담기는 내용은 LE와 같지만 **최초 실행 시의 스냅샷을 유지**한다는 점이 다름. 실행 컨텍스트를 생성할 때 VE에 정보를 먼저 담고, 그대로 복사해서 LE를 만든 후, 그 다음에는 LE를 활용

#### *LexicalEnvironment(LE)
직역하면 어휘적 환경. 컨텍스트를 구성하는 환경 정보들을 사전에서 접하는 느낌으로 모아 놓은 것. 동적인 성질을 띔  

##### environmentRecord
현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다  
1. 매개변수 식별자
2. 선언한 함수 자체
3. 변수의 식별자

###### 호이스팅
변수 정보를 수집하는 과정을 모두 마쳤더라도 아직 실행 컨텍스트가 관여할 코드들은 실행되기 이전의 상태  
코드가 실행되기 전임에도 불구하고 **자스 엔진은 이미 해당 환경에 속한 코드의 변수명을 모두 알고 있음**  
=== **자스엔진은 식별자들을 최상단으로 끌어올려놓은 다음 실제 코드를 실행한다** - 라고 생각해도 문제될 것이 없음  
실제로 그렇다는 건 아니고 편의상 그렇게 간주하자는 것  

###### 호이스팅 규칙

매개변수와 변수
```javascript
// 호이스팅 없음
function a(x) { // 수집대상 1 - 매개변수
  console.log(x);
  var x; // 수집대상 2 - 변수선언
  console.log(x);
  var x = 2; // 수집대상 2 - 변수선언
  console.log(x);
}
a(1)

// 호이스팅 됐음
function a() {
  var x;
  var x; // 이미 변수가 선언되었으므로 무시해야함
  var x;

  x = 1;
  console.log(x);
  console.log(x);

  x = 2;
  console.log(x);
}
a(1);
```
함수 선언
```javascript
// 호이스팅 없음
function a() {
  console.log(b);
  var b = 'bbb';
  console.log(b);
  function b(){}
  console.log(b);
}
a();

// 호이스팅 됐음
function a() {
  var b; // 수집대상 1. 변수는 선언부만 끌어올린다
  function b () {} // 수집대상 2. 함수 선언은 전체를 끌어올린다
  // 호이스팅이 끝난 후의 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것처럼 여길 수 있음

  // var b = function b () {}

  console.log(b);
  b = 'bbb';
  console.log(b);
  console.log(b);
}
a();
```
###### var말고 let이라면?
호이스팅은 되지만 선언 전에 접근할 수 없다 [#이유](letConstvsVar.md)  
var : 스코프에 수집된 순간부터 접근 가능(선언+초기화-메모리할당)
let : 수집된 후 메모리에 할당되어야 접근 가능(only 선언)

```javascript
function a() {
  console.log(b);
  let b = 'bbb';
  console.log(b);
  function b(){}
  console.log(b);
}
a();

/*
var일 경우 - 1) 함수객체 b, 2) bbb 3) bbb
let일 경우 - 1) 에러 (not defined)
*/
```

###### 함수 선언문 vs 함수 표현식
함수 선언문은 전체를 호이스팅한 반면 함수 표현식은 변수 선언부만 호이스팅됨
```javascript
// 호이스팅 적용 x
console.log(sum(1,2));
console.log(multiply(3,4));

function sum(a,b) {
  return a+b;
}

var multiply = function(a,b) {
  return a*b
}

//호이스팅 적용 o
var sum = function sum(a,b) {
  // 선언 전에 호출해도 아무 문제 없이 실행됨 (ㄷㄷ;)
  return a+b;
}

var multiply;
console.log(sum(1,2));
console.log(multiply(3,4));

multiply = function(a,b) {
  // 변수만 선언부가 호이스팅 되므로 선언 전에 호출할 수 없음
  // 상대적으로 함수 표현식이 더 안전하다
  return a*b;
}
```

##### outerEnvironmentReference(ER)
스코프 : 식별자에 대한 유효범위  
스코프 체인 : 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것
```shell
es5까지 : 오직 함수에 의해서만 스코프가 생성됨 - 
함수가 아니라 조건문이나 반복문 내에서 선언한 변수는 무족권 전역변수가 됨(ㄷㄷ;)

es6 : 블록 스코프에서도 경계 발생- let, const 
```
ER은 현재 호출된 함수가 선언될 당시의 LE를 참조함(연결리스트 형태)  
계속 올라가다 보면 전역 컨텍스트의 LE가 있을 것  
여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에게만 접근 가능**  

###### 변수 은닉화
그런데 **스코프 체인 상의 변수라고 해서 무조건 접근 가능하진 않음**  
inner함수 안의 console.log(a)가 undefined를 뱉는 이유는 inner스코프에 LE에 a 식별자가 존재하므로  
스코프 체인 검색을 진행하지 않고 a를 반환하게 되는 것

## Reference
- [코어 자바스크립트 - 실행 컨텍스트](http://www.yes24.com/Product/Goods/78586788?scode=032&OzSrank=1)